var U = {
  // enums
  DeviceIndepenedent: 0,
  // device independent units: 96/inch
  Centimeters: 1,
  Millimeters: 2,
  Inches: 3,
  // constants for device independent units (diu)
  DIU_PER_INCH: 96,
  DIU_PER_CENTIMETER: 37.79527559055118,
  ToDeviceIndependent: function(o, t) {
    switch (t) {
      case ht:
        return o * DIU_PER_CENTIMETER;
      case lt:
        return o * DIU_PER_CENTIMETER / 10;
      case ut:
        return o * DIU_PER_INCH;
      default:
        return o;
    }
  },
  FromDeviceIndependent: function(o, t) {
    switch (t) {
      case ht:
        return o / DIU_PER_CENTIMETER;
      case lt:
        return o / DIU_PER_CENTIMETER * 10;
      case ut:
        return o / DIU_PER_INCH;
      default:
        return o;
    }
  },
  StringToUnitsType: function(o) {
    switch (o.ToLower()) {
      case "in":
      case "inches":
        return ut;
      case "cm":
      case "centimeters":
        return ht;
      case "mm":
      case "millimeters":
        return lt;
      case "di":
      case "device-independent":
        return DeviceIndepenedent;
      default:
        return DeviceIndepenedent;
    }
  },
  UnitsTypeToString: function(o) {
    switch (o) {
      case ut:
        return "in";
      case ht:
        return "cm";
      case lt:
        return "mm";
      case DeviceIndepenedent:
        return "device-independent";
      default:
        return "device-independent";
    }
  }
};
function MA(o) {
  return o;
}
function ht(o) {
  return U.ToDeviceIndependent(o, U.Centimeters);
}
function lt(o) {
  return U.ToDeviceIndependent(o, U.Millimeters);
}
function ut(o) {
  return U.ToDeviceIndependent(o, U.Inches);
}
function EA(o) {
  return U.FromDeviceIndependent(o, U.Centimeters);
}
function ZA(o) {
  return U.FromDeviceIndependent(o, U.Millimeters);
}
function FA(o) {
  return U.FromDeviceIndependent(o, U.Inches);
}
class nt {
  constructor(t, A) {
    this.x = typeof t < "u" ? t : 0, this.y = typeof A < "u" ? A : 0;
  }
  clone() {
    return new nt(this.x, this.y);
  }
  equals(t) {
    return this.x === t.x && this.y === t.y;
  }
}
class R {
  constructor(t, A, e, s) {
    this.x = typeof t < "u" ? t : 1 / 0, this.y = typeof A < "u" ? A : 1 / 0, this.width = typeof e < "u" ? e : -1 / 0, this.height = typeof s < "u" ? s : -1 / 0;
  }
  clone() {
    return new R(this.x, this.y, this.width, this.height);
  }
  isEmpty() {
    return this.x === 1 / 0 && this.y === 1 / 0 && this.width === -1 / 0 && this.height === -1 / 0;
  }
  // convenience method
  right() {
    return this.x + this.width;
  }
  bottom() {
    return this.y + this.height;
  }
  equals(t) {
    return this.x === t.x && this.y === t.y && this.width === t.width && this.height === t.height;
  }
  // other can be a Point or a Rect
  contains(t) {
    return t instanceof nt ? t.x >= this.x && t.x <= this.x + this.width && t.y >= this.y && t.y <= this.y + this.height : this.x <= t.x && this.x + this.width >= t.x + t.width && this.y <= t.y && this.y + this.height >= t.y + t.height;
  }
  union(t) {
    var A = Math.max(this.x + this.width, t.x + t.width), e = Math.max(this.y + this.height, t.y + t.height);
    this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.width = A - this.x, this.height = e - this.y;
  }
}
class Yt {
  constructor(t, A, e, s) {
    this.left = typeof t < "u" ? t : 0, this.top = typeof A < "u" ? A : 0, this.right = typeof e < "u" ? e : 0, this.bottom = typeof s < "u" ? s : 0;
  }
  clone() {
    return new Yt(this.left, this.top, this.right, this.bottom);
  }
  equals(t) {
    return this.left === t.left && this.top === t.top && this.right === t.right && this.bottom === t.bottom;
  }
}
class Rt {
  constructor(t, A) {
    this.width = typeof t < "u" ? t : 0, this.height = typeof A < "u" ? A : 0;
  }
  clone() {
    return new Rt(this.width, this.height);
  }
  equals(t) {
    return this.width === t.width && this.height === t.height;
  }
}
var y = {
  Do: 0,
  Du: 1,
  Re: 2,
  Me: 3,
  Mi: 4,
  Fa: 5,
  Fu: 6,
  So: 7,
  La: 9,
  Te: 10,
  Ti: 11
}, Ot = [0, 0, 1, 1, 2, 3, 3, 4, 4, 5, 6, 6], dt = [y.Do, y.Re, y.Mi, y.Fa, y.So, y.La, y.Ti];
class W {
  constructor(t, A) {
    this.step = t, this.octave = A;
  }
  toInt() {
    return this.octave * 12 + this.step;
  }
  isHigherThan(t) {
    return this.toInt() > t.toInt();
  }
  isLowerThan(t) {
    return this.toInt() < t.toInt();
  }
  equals(t) {
    return this.toInt() === t.toInt();
  }
  static stepToStaffOffset(t) {
    return Ot[t];
  }
  static staffOffsetToStep(t) {
    for (; t < 0; )
      t = dt.length + t;
    return dt[t % dt.length];
  }
}
function UA() {
  function o() {
    return Math.floor((1 + Math.random()) * 65536).toString(16).substring(1);
  }
  return o() + o();
}
let it = {
  None: {
    svgSrc: "<g></g>",
    paths: [{
      type: "positive",
      data: ""
    }],
    bounds: {
      x: 0,
      y: 0,
      width: 0,
      height: 0
    },
    origin: {
      x: 0,
      y: 0
    },
    align: "left"
  },
  AcuteAccent: {
    svgSrc: '<path d="M4 0C-.614.52-.614.52-.803-3.182l60.768-108.422c4.52-7.182 10.543-13.67 18.075-13.67 5.27 0 14.31 1.264 23.346 7.793 7.53 5.223 8.803 11.752 8.803 16.975 0 3.917-.52 11.1-8.05 17.628L4 0z"/>',
    paths: [{
      type: "positive",
      data: "M4 0C-.614.52-.614.52-.803-3.182l60.768-108.422c4.52-7.182 10.543-13.67 18.075-13.67 5.27 0 14.31 1.264 23.346 7.793 7.53 5.223 8.803 11.752 8.803 16.975 0 3.917-.52 11.1-8.05 17.628L4 0z"
    }],
    bounds: {
      x: 0,
      y: 0,
      width: 110.99200439453125,
      height: 125.79399108886719
    },
    origin: {
      x: 0.8030000329017639,
      y: 125.27399444580078
    },
    align: "left"
  },
  Stropha: {
    svgSrc: '<path d="M1.22-73.438c4.165 13.02 12.238 27.084 24.217 42.188L49.657 0 34.812 27.344C18.666 55.47-.084 72.396-21.438 78.124c4.687-3.645 7.03-8.593 7.03-14.843 0-8.853-4.947-20.572-14.843-35.155L-48 0 1.22-73.438z"/>',
    paths: [{
      type: "positive",
      data: "M1.22-73.438c4.165 13.02 12.238 27.084 24.217 42.188L49.657 0 34.812 27.344C18.666 55.47-.084 72.396-21.438 78.124c4.687-3.645 7.03-8.593 7.03-14.843 0-8.853-4.947-20.572-14.843-35.155L-48 0 1.22-73.438z"
    }],
    bounds: {
      x: 0,
      y: 0,
      width: 97.65699768066406,
      height: 151.56201171875
    },
    origin: {
      x: 48,
      y: 73.43800354003906
    },
    align: "left"
  },
  BeginningAscLiquescent: {
    svgSrc: '<path d="M-50 43.688V-61c4.167 7.292 12.76 10.938 25.78 10.938 9.376 0 20.053-1.563 32.032-4.688C31.773-60.48 45.833-71.677 50-88.344v117.97C43.75 42.645 32.812 51.5 17.187 56.186-.52 61.398-15.886 64-28.906 64-42.97 64-50 57.23-50 43.687z"/>',
    paths: [{
      type: "positive",
      data: "M-50 43.688V-61c4.167 7.292 12.76 10.938 25.78 10.938 9.376 0 20.053-1.563 32.032-4.688C31.773-60.48 45.833-71.677 50-88.344v117.97C43.75 42.645 32.812 51.5 17.187 56.186-.52 61.398-15.886 64-28.906 64-42.97 64-50 57.23-50 43.687z"
    }],
    bounds: {
      x: 0,
      y: 0,
      width: 100,
      height: 152.343994140625
    },
    origin: {
      x: 50,
      y: 88.34400177001953
    },
    align: "left"
  },
  BeginningDesLiquescent: {
    svgSrc: '<path d="M-50-56.03c0-13.022 7.03-19.532 21.094-19.532 13.02 0 28.385 2.604 46.093 7.812C32.813-63.583 43.75-54.73 50-41.187V76C45.833 59.854 31.77 48.656 7.812 42.406c-11.98-3.125-22.656-4.687-32.03-4.687-13.022 0-21.615 3.905-25.782 11.718v-105.47z"/>',
    paths: [{
      type: "positive",
      data: "M-50-56.03c0-13.022 7.03-19.532 21.094-19.532 13.02 0 28.385 2.604 46.093 7.812C32.813-63.583 43.75-54.73 50-41.187V76C45.833 59.854 31.77 48.656 7.812 42.406c-11.98-3.125-22.656-4.687-32.03-4.687-13.022 0-21.615 3.905-25.782 11.718v-105.47z"
    }],
    bounds: {
      x: 0,
      y: 0,
      width: 100,
      height: 151.56199645996094
    },
    origin: {
      x: 50,
      y: 75.56199645996094
    },
    align: "left"
  },
  CustosDescLong: {
    svgSrc: '<path d="M39.063 273.472c5.73.52 7.29-6.25 4.687-20.312V-65.59c-13.542 2.083-24.22 5.468-32.03 10.156C3.905-50.226 0-43.714 0-35.904V71.91c5.73-5.21 10.677-8.594 14.844-10.157 5.73-1.562 12.24-2.343 19.53-2.343v196.875c0 11.458 1.563 17.187 4.688 17.187z"/>',
    paths: [{
      type: "positive",
      data: "M39.063 273.472c5.73.52 7.29-6.25 4.687-20.312V-65.59c-13.542 2.083-24.22 5.468-32.03 10.156C3.905-50.226 0-43.714 0-35.904V71.91c5.73-5.21 10.677-8.594 14.844-10.157 5.73-1.562 12.24-2.343 19.53-2.343v196.875c0 11.458 1.563 17.187 4.688 17.187"
    }],
    bounds: {
      x: 0,
      y: 0,
      width: 46.35300064086914,
      height: 339.58197021484375
    },
    origin: {
      x: 0,
      y: 65.58999633789062
    },
    align: "left"
  },
  CustosDescShort: {
    svgSrc: '<path d="M34.375 191.923c0 8.333 1.563 12.24 4.688 11.72 3.125-.522 4.687-7.033 4.687-19.533v-250c-13.542 2.084-24.22 5.47-32.03 10.157C3.905-50.525 0-44.015 0-36.203V71.61c5.73-5.208 10.677-8.593 14.844-10.156 5.73-1.562 12.24-2.344 19.53-2.344v132.813z"/>',
    paths: [{
      type: "positive",
      data: "M34.375 191.923c0 8.333 1.563 12.24 4.688 11.72 3.125-.522 4.687-7.033 4.687-19.533v-250c-13.542 2.084-24.22 5.47-32.03 10.157C3.905-50.525 0-44.015 0-36.203V71.61c5.73-5.208 10.677-8.593 14.844-10.156 5.73-1.562 12.24-2.344 19.53-2.344v132.813z"
    }],
    bounds: {
      x: 0,
      y: 0,
      width: 43.75,
      height: 270.0530090332031
    },
    origin: {
      x: 0,
      y: 65.88999938964844
    },
    align: "left"
  },
  CustosLong: {
    svgSrc: '<path d="M39.063-269.562c5.73-.52 7.29 6.25 4.687 20.312V69.5c-13.542-2.083-24.22-5.47-32.03-10.156C3.905 54.134 0 47.624 0 39.812V-68c5.73 5.208 10.677 8.594 14.844 10.156 5.73 1.563 12.24 2.344 19.53 2.344v-196.875c0-11.458 1.563-17.187 4.688-17.187z"/>',
    paths: [{
      type: "positive",
      data: "M39.063-269.562c5.73-.52 7.29 6.25 4.687 20.312V69.5c-13.542-2.083-24.22-5.47-32.03-10.156C3.905 54.134 0 47.624 0 39.812V-68c5.73 5.208 10.677 8.594 14.844 10.156 5.73 1.563 12.24 2.344 19.53 2.344v-196.875c0-11.458 1.563-17.187 4.688-17.187z"
    }],
    bounds: {
      x: 0,
      y: 0,
      width: 46.35300064086914,
      height: 339.5820007324219
    },
    origin: {
      x: 0,
      y: 270.0820007324219
    },
    align: "left"
  },
  CustosShort: {
    svgSrc: '<path d="M34.375-188.125c0-8.333 1.563-12.24 4.688-11.72 3.125.522 4.687 7.033 4.687 19.532v250c-13.542-2.083-24.22-5.468-32.03-10.156C3.905 54.324 0 47.813 0 40V-67.813c5.73 5.21 10.677 8.594 14.844 10.157 5.73 1.562 12.24 2.344 19.53 2.343v-132.812z"/>',
    paths: [{
      type: "positive",
      data: "M34.375-188.125c0-8.333 1.563-12.24 4.688-11.72 3.125.522 4.687 7.033 4.687 19.532v250c-13.542-2.083-24.22-5.468-32.03-10.156C3.905 54.324 0 47.813 0 40V-67.813c5.73 5.21 10.677 8.594 14.844 10.157 5.73 1.562 12.24 2.344 19.53 2.343v-132.812z"
    }],
    bounds: {
      x: 0,
      y: 0,
      width: 43.75,
      height: 270.052001953125
    },
    origin: {
      x: 0,
      y: 200.36500549316406
    },
    align: "left"
  },
  DoClef: {
    svgSrc: '<path d="M0 98.406V-97.688C0-118 5.99-134.275 17.97-146.516c11.978-12.24 27.603-18.36 46.874-18.36 10.937 0 19.53 3.126 25.78 9.376s9.376 14.583 9.376 25v107.813l-6.25-5.47c-4.167-3.645-10.287-7.42-18.36-11.327-8.072-3.907-16.796-5.86-26.17-5.86-11.46 0-21.486 4.427-30.08 13.282-8.593 8.854-12.89 19.53-12.89 32.03s4.297 23.308 12.89 32.423c8.594 9.115 18.62 13.672 30.08 13.672 9.374 0 18.098-1.822 26.17-5.468 8.073-3.646 14.193-7.292 18.36-10.938l6.25-6.25V132c0 9.896-3.125 18.1-9.375 24.61-6.25 6.51-14.844 9.765-25.78 9.765-19.272 0-34.897-6.25-46.876-18.75C5.99 135.125 0 118.72 0 98.405z"/>',
    paths: [{
      type: "positive",
      data: "M0 98.406V-97.688C0-118 5.99-134.275 17.97-146.516c11.978-12.24 27.603-18.36 46.874-18.36 10.937 0 19.53 3.126 25.78 9.376s9.376 14.583 9.376 25v107.813l-6.25-5.47c-4.167-3.645-10.287-7.42-18.36-11.327-8.072-3.907-16.796-5.86-26.17-5.86-11.46 0-21.486 4.427-30.08 13.282-8.593 8.854-12.89 19.53-12.89 32.03s4.297 23.308 12.89 32.423c8.594 9.115 18.62 13.672 30.08 13.672 9.374 0 18.098-1.822 26.17-5.468 8.073-3.646 14.193-7.292 18.36-10.938l6.25-6.25V132c0 9.896-3.125 18.1-9.375 24.61-6.25 6.51-14.844 9.765-25.78 9.765-19.272 0-34.897-6.25-46.876-18.75C5.99 135.125 0 118.72 0 98.405z"
    }],
    bounds: {
      x: 0,
      y: 0,
      width: 100,
      height: 331.2510070800781
    },
    origin: {
      x: 0,
      y: 164.87600708007812
    },
    align: "left"
  },
  FaClef: {
    svgSrc: '<path d="M85.156-32v193.75c0 9.375-1.562 14.323-4.687 14.844-1.564 0-2.605-.52-3.126-1.563-.52-1.04-.782-2.603-.78-4.686V56.28c-8.335-8.332-19.793-12.5-34.376-12.5-17.71 0-31.77 3.907-42.188 11.72V-32c0-18.23 14.193-27.344 42.578-27.344 28.385 0 42.578 9.115 42.578 27.344zM98.438 93V-92.156c0-19.27 5.73-34.896 17.187-46.875 11.458-11.98 26.562-17.97 45.313-17.97 10.937 0 19.14 2.865 24.61 8.594 5.467 5.73 8.202 13.542 8.202 23.437v103.126l-5.47-4.687c-3.645-3.647-9.374-7.293-17.186-10.94-7.813-3.645-15.886-5.467-24.22-5.468-11.978 0-22.004 4.167-30.077 12.5-8.073 8.334-12.11 18.36-12.11 30.08 0 11.717 4.037 22.004 12.11 30.858s18.1 13.28 30.078 13.28c8.333 0 16.406-1.822 24.22-5.468 7.81-3.645 13.54-7.03 17.186-10.156l5.47-5.468V125.81c0 9.896-2.865 17.84-8.594 23.83-5.73 5.988-13.802 8.983-24.22 8.983-18.75 0-33.853-6.12-45.31-18.36-11.46-12.24-17.19-27.994-17.19-47.265z"/>',
    paths: [{
      type: "positive",
      data: "M85.156-32v193.75c0 9.375-1.562 14.323-4.687 14.844-1.564 0-2.605-.52-3.126-1.563-.52-1.04-.782-2.603-.78-4.686V56.28c-8.335-8.332-19.793-12.5-34.376-12.5-17.71 0-31.77 3.907-42.188 11.72V-32c0-18.23 14.193-27.344 42.578-27.344 28.385 0 42.578 9.115 42.578 27.344zM98.438 93V-92.156c0-19.27 5.73-34.896 17.187-46.875 11.458-11.98 26.562-17.97 45.313-17.97 10.937 0 19.14 2.865 24.61 8.594 5.467 5.73 8.202 13.542 8.202 23.437v103.126l-5.47-4.687c-3.645-3.647-9.374-7.293-17.186-10.94-7.813-3.645-15.886-5.467-24.22-5.468-11.978 0-22.004 4.167-30.077 12.5-8.073 8.334-12.11 18.36-12.11 30.08 0 11.717 4.037 22.004 12.11 30.858s18.1 13.28 30.078 13.28c8.333 0 16.406-1.822 24.22-5.468 7.81-3.645 13.54-7.03 17.186-10.156l5.47-5.468V125.81c0 9.896-2.865 17.84-8.594 23.83-5.73 5.988-13.802 8.983-24.22 8.983-18.75 0-33.853-6.12-45.31-18.36-11.46-12.24-17.19-27.994-17.19-47.265z"
    }],
    bounds: {
      x: 0,
      y: 0,
      width: 193.75201416015625,
      height: 333.5950012207031
    },
    origin: {
      x: 0.001003265380859375,
      y: 157.00100708007812
    },
    align: "left"
  },
  Flat: {
    svgSrc: '<path d="M7.813-204.406c4.166 0 6.25 5.208 6.25 15.625L12.5-10.657C33.854 13.302 54.167 25.28 73.438 25.28c9.374 0 14.062-4.686 14.062-14.06 0-6.25-1.042-11.72-3.125-16.407-2.083-4.688-7.03-9.766-14.844-15.235-7.81-5.47-13.02-8.984-15.624-10.547L27.344-45.81V-80.97c17.187 0 33.073 4.82 47.656 14.454C89.583-56.88 96.875-47.376 96.875-38c0 67.708-.26 101.562-.78 101.563-38.543 0-69.532-12.24-92.97-36.72C0-52.322-1.042-123.936 0-188c0-10.937 2.604-16.406 7.813-16.406z"/>',
    paths: [{
      type: "positive",
      data: "M7.813-204.406c4.166 0 6.25 5.208 6.25 15.625L12.5-10.657C33.854 13.302 54.167 25.28 73.438 25.28c9.374 0 14.062-4.686 14.062-14.06 0-6.25-1.042-11.72-3.125-16.407-2.083-4.688-7.03-9.766-14.844-15.235-7.81-5.47-13.02-8.984-15.624-10.547L27.344-45.81V-80.97c17.187 0 33.073 4.82 47.656 14.454C89.583-56.88 96.875-47.376 96.875-38c0 67.708-.26 101.562-.78 101.563-38.543 0-69.532-12.24-92.97-36.72C0-52.322-1.042-123.936 0-188c0-10.937 2.604-16.406 7.813-16.406z"
    }],
    bounds: {
      x: 0,
      y: 0,
      width: 97.91699981689453,
      height: 267.968994140625
    },
    origin: {
      x: 1.0420000553131104,
      y: 204.406005859375
    },
    align: "left"
  },
  Mora: {
    svgSrc: '<path d="M47.478-24c6.957 0 12.793 2.288 17.49 6.883C69.662-12.52 72-6.904 72-.267c0 6.64-2.337 12.352-7.033 17.118C60.27 21.618 54.435 24 47.477 24c-6.26 0-11.748-2.383-16.444-7.15C26.337 12.086 24 6.374 24-.265c0-6.638 2.337-12.255 7.033-16.85C35.73-21.713 41.217-24 47.478-24z"/>',
    paths: [{
      type: "positive",
      data: "M47.478-24c6.957 0 12.793 2.288 17.49 6.883C69.662-12.52 72-6.904 72-.267c0 6.64-2.337 12.352-7.033 17.118C60.27 21.618 54.435 24 47.477 24c-6.26 0-11.748-2.383-16.444-7.15C26.337 12.086 24 6.374 24-.265c0-6.638 2.337-12.255 7.033-16.85C35.73-21.713 41.217-24 47.478-24z"
    }],
    bounds: {
      x: 0,
      y: 0,
      width: 48,
      height: 48
    },
    origin: {
      x: -24,
      y: 24
    },
    align: "left"
  },
  Natural: {
    svgSrc: '<path d="M7.906-166.563c-2.864 0-5.614.52-8.218 1.563v13.28l.78 56.25.782 78.907v85.157c.52 3.646 2.604 5.73 6.25 6.25l23.438-3.906 23.437-3.907v29.69c0 42.186-.26 63.54-.78 64.06l6.25 2.345c1.04.52 2.082.78 3.124.78 2.603 0 4.947-1.3 7.03-3.905L67.656-71.25c-.52-2.604-2.083-3.906-4.687-3.906-7.814 0-17.19 1.04-28.126 3.125l-19.53 3.124.78-38.28V-165c-2.604-1.042-5.323-1.562-8.188-1.563zM55.938-40v71.875l-41.407 7.03c0-48.436.262-72.655.783-72.655L55.938-40z"/>',
    paths: [{
      type: "positive",
      data: "M7.906-166.563c-2.864 0-5.614.52-8.218 1.563v13.28l.78 56.25.782 78.907v85.157c.52 3.646 2.604 5.73 6.25 6.25l23.438-3.906 23.437-3.907v29.69c0 42.186-.26 63.54-.78 64.06l6.25 2.345c1.04.52 2.082.78 3.124.78 2.603 0 4.947-1.3 7.03-3.905L67.656-71.25c-.52-2.604-2.083-3.906-4.687-3.906-7.814 0-17.19 1.04-28.126 3.125l-19.53 3.124.78-38.28V-165c-2.604-1.042-5.323-1.562-8.188-1.563zM55.938-40v71.875l-41.407 7.03c0-48.436.262-72.655.783-72.655L55.938-40z"
    }],
    bounds: {
      x: 0,
      y: 0,
      width: 70.31100463867188,
      height: 330.468994140625
    },
    origin: {
      x: 0.3120002746582031,
      y: 166.56300354003906
    },
    align: "left"
  },
  OriscusAsc: {
    svgSrc: '<path d="M50 30.25c0 12.5-3.125 21.354-9.375 26.562-3.125 2.605-7.813 3.907-14.063 3.907-3.125 0-5.99-.522-8.593-1.564-2.605-1.04-5.6-2.474-8.986-4.297C5.6 53.035 2.734 51.603.39 50.56c-2.343-1.04-5.338-2.474-8.984-4.296-3.646-1.823-6.77-3.256-9.375-4.297-2.603-1.043-5.468-1.564-8.593-1.564-6.25 0-10.937 1.563-14.062 4.688C-46.875 50.824-50 59.677-50 71.656v-106.25c0-13.02 3.125-21.875 9.375-26.562 3.125-2.604 7.813-3.906 14.063-3.907 3.125 0 5.99.52 8.593 1.563 2.605 1.042 5.73 2.474 9.376 4.297 3.646 1.823 6.51 2.995 8.594 3.516l10.938 5.468c6.25 3.126 11.458 4.69 15.624 4.69 6.25 0 10.938-1.564 14.063-4.69C46.875-55.426 50-64.02 50-76V30.25z"/>',
    paths: [{
      type: "positive",
      data: "M50 30.25c0 12.5-3.125 21.354-9.375 26.562-3.125 2.605-7.813 3.907-14.063 3.907-3.125 0-5.99-.522-8.593-1.564-2.605-1.04-5.6-2.474-8.986-4.297C5.6 53.035 2.734 51.603.39 50.56c-2.343-1.04-5.338-2.474-8.984-4.296-3.646-1.823-6.77-3.256-9.375-4.297-2.603-1.043-5.468-1.564-8.593-1.564-6.25 0-10.937 1.563-14.062 4.688C-46.875 50.824-50 59.677-50 71.656v-106.25c0-13.02 3.125-21.875 9.375-26.562 3.125-2.604 7.813-3.906 14.063-3.907 3.125 0 5.99.52 8.593 1.563 2.605 1.042 5.73 2.474 9.376 4.297 3.646 1.823 6.51 2.995 8.594 3.516l10.938 5.468c6.25 3.126 11.458 4.69 15.624 4.69 6.25 0 10.938-1.564 14.063-4.69C46.875-55.426 50-64.02 50-76V30.25z"
    }],
    bounds: {
      x: 0,
      y: 0,
      width: 100,
      height: 147.656005859375
    },
    origin: {
      x: 50,
      y: 76
    },
    align: "left"
  },
  OriscusDes: {
    svgSrc: '<path d="M-50 30.844v-106.25c0 11.458 3.125 20.052 9.375 25.78 3.125 3.126 7.813 4.69 14.063 4.688 4.687 0 13.41-3.255 26.17-9.765 12.762-6.51 21.746-9.766 26.954-9.766 6.25 0 10.938 1.303 14.063 3.907C46.875-55.874 50-47.02 50-34V72.25c0-11.98-3.125-20.833-9.375-26.563C37.5 42.563 32.812 41 26.562 41 21.875 41 13.023 44.385 0 51.156c-4.167 2.604-8.594 4.948-13.28 7.032-4.69 2.083-9.116 3.124-13.283 3.124-6.25 0-10.937-1.302-14.062-3.906C-46.875 52.198-50 43.344-50 30.844z"/>',
    paths: [{
      type: "positive",
      data: "M-50 30.844v-106.25c0 11.458 3.125 20.052 9.375 25.78 3.125 3.126 7.813 4.69 14.063 4.688 4.687 0 13.41-3.255 26.17-9.765 12.762-6.51 21.746-9.766 26.954-9.766 6.25 0 10.938 1.303 14.063 3.907C46.875-55.874 50-47.02 50-34V72.25c0-11.98-3.125-20.833-9.375-26.563C37.5 42.563 32.812 41 26.562 41 21.875 41 13.023 44.385 0 51.156c-4.167 2.604-8.594 4.948-13.28 7.032-4.69 2.083-9.116 3.124-13.283 3.124-6.25 0-10.937-1.302-14.062-3.906C-46.875 52.198-50 43.344-50 30.844z"
    }],
    bounds: {
      x: 0,
      y: 0,
      width: 100,
      height: 147.656005859375
    },
    origin: {
      x: 50,
      y: 75.40599822998047
    },
    align: "left"
  },
  OriscusLiquescent: {
    svgSrc: '<path d="M 19.05539,78.886528 C 20.242277,78.486807 21.532179,77.890297 22.925106,77.09701 24.317891,76.303653 26.700882,74.417241 30.074091,71.437777 33.447144,68.45824 36.523539,64.985185 39.303286,61.018598 42.082855,57.051975 44.562739,51.395765 46.742952,44.049969 48.922975,36.704172 50.01304,28.671032 50.013135,19.950525 L 50.013135,-34.225545 C 50.01304,-54.464261 42.07377,-64.583661 26.195289,-64.583768 20.248326,-64.583661 11.518758,-61.410372 0.00656131,-55.06389 -11.505742,-48.717218 -20.23531,-45.543929 -26.182179,-45.544024 -34.515109,-45.543929 -40.567968,-48.520405 -44.340791,-54.473441 -48.113613,-60.426286 -50.000025,-67.369373 -50.000025,-75.302702 L -50.000025,30.069925 C -50.000025,49.909039 -42.060754,59.828603 -26.182179,59.828615 -21.022584,59.828603 -12.38991,56.455465 -0.28412107,49.709203 11.821549,42.96294 20.648023,39.589803 26.195289,39.589803 29.368506,40.776762 30.361665,44.249817 29.17479,50.00897 27.987759,55.768122 26.00143,62.020829 23.215789,68.767116 z"/>',
    paths: [{
      type: "positive",
      data: "M 19.05539,78.886528 C 20.242277,78.486807 21.532179,77.890297 22.925106,77.09701 24.317891,76.303653 26.700882,74.417241 30.074091,71.437777 33.447144,68.45824 36.523539,64.985185 39.303286,61.018598 42.082855,57.051975 44.562739,51.395765 46.742952,44.049969 48.922975,36.704172 50.01304,28.671032 50.013135,19.950525 L 50.013135,-34.225545 C 50.01304,-54.464261 42.07377,-64.583661 26.195289,-64.583768 20.248326,-64.583661 11.518758,-61.410372 0.00656131,-55.06389 -11.505742,-48.717218 -20.23531,-45.543929 -26.182179,-45.544024 -34.515109,-45.543929 -40.567968,-48.520405 -44.340791,-54.473441 -48.113613,-60.426286 -50.000025,-67.369373 -50.000025,-75.302702 L -50.000025,30.069925 C -50.000025,49.909039 -42.060754,59.828603 -26.182179,59.828615 -21.022584,59.828603 -12.38991,56.455465 -0.28412107,49.709203 11.821549,42.96294 20.648023,39.589803 26.195289,39.589803 29.368506,40.776762 30.361665,44.249817 29.17479,50.00897 27.987759,55.768122 26.00143,62.020829 23.215789,68.767116 z"
    }],
    bounds: {
      x: 0,
      y: 0,
      width: 100,
      height: 147.656005859375
    },
    origin: {
      x: 50,
      y: 75.40599822998047
    },
    align: "left"
  },
  PodatusLower: {
    svgSrc: '<path d="M-4.688-30.28c22.396 0 34.636-.262 36.72-.782 5.728-1.563 8.593-5.21 8.593-10.938H50v97.656c0 2.604-1.302 4.167-3.906 4.688-5.21.52-21.355.78-48.438.78-23.958 0-38.54-.26-43.75-.78-2.604 0-3.906-1.302-3.906-3.906v-82.032c0-3.646 1.302-5.468 3.906-5.468h2.344c2.604.52 15.625.78 39.063.78z"/>',
    paths: [{
      type: "positive",
      data: "M-4.688-30.28c22.396 0 34.636-.262 36.72-.782 5.728-1.563 8.593-5.21 8.593-10.938H50v97.656c0 2.604-1.302 4.167-3.906 4.688-5.21.52-21.355.78-48.438.78-23.958 0-38.54-.26-43.75-.78-2.604 0-3.906-1.302-3.906-3.906v-82.032c0-3.646 1.302-5.468 3.906-5.468h2.344c2.604.52 15.625.78 39.063.78z"
    }],
    bounds: {
      x: 0,
      y: 0,
      width: 100,
      height: 103.12399291992188
    },
    origin: {
      x: 50,
      y: 42
    },
    align: "left"
  },
  PodatusUpper: {
    svgSrc: '<path d="M-46.094-63.78c13.542 0 24.61 2.473 33.203 7.42C-4.298-51.41 0-43.99 0-34.093V62h-9.375c0-10.938-2.604-19.14-7.812-24.61-5.21-5.468-14.844-8.203-28.907-8.202-18.23 0-33.333 4.166-45.312 12.5v-75.782c0-19.79 15.104-29.687 45.312-29.687z"/>',
    paths: [{
      type: "positive",
      data: "M-46.094-63.78c13.542 0 24.61 2.473 33.203 7.42C-4.298-51.41 0-43.99 0-34.093V62h-9.375c0-10.938-2.604-19.14-7.812-24.61-5.21-5.468-14.844-8.203-28.907-8.202-18.23 0-33.333 4.166-45.312 12.5v-75.782c0-19.79 15.104-29.687 45.312-29.687z"
    }],
    bounds: {
      x: 0,
      y: 0,
      width: 91.406005859375,
      height: 125.78099822998047
    },
    origin: {
      x: 91.406005859375,
      y: 63.78099822998047
    },
    align: "right"
  },
  Porrectus1: {
    svgSrc: '<path d="M233.594 162.875c-58.855 0-107.032-6.25-144.53-18.75C34.895 125.895-11.46 99.855-50 66V-52.75C-21.354-24.625 26.302 6.885 92.97 41.78 123.697 57.928 163.54 66 212.5 66c21.354 0 34.635-9.896 39.844-29.688V151.94c0 7.29-6.25 10.937-18.75 10.937z"/>',
    paths: [{
      type: "positive",
      data: "M233.594 162.875c-58.855 0-107.032-6.25-144.53-18.75C34.895 125.895-11.46 99.855-50 66V-52.75C-21.354-24.625 26.302 6.885 92.97 41.78 123.697 57.928 163.54 66 212.5 66c21.354 0 34.635-9.896 39.844-29.688V151.94c0 7.29-6.25 10.937-18.75 10.937z"
    }],
    bounds: {
      x: 0,
      y: 0,
      width: 302.343994140625,
      height: 215.6269989013672
    },
    origin: {
      x: 50,
      y: 52.75
    },
    align: "left"
  },
  Porrectus2: {
    svgSrc: '<path d="M309.375 259.375c-50.52 0-110.938-22.396-181.25-67.188C48.437 141.667-10.938 94.272-50 50V-68.75C0-3.125 60.417 52.083 131.25 96.875c58.333 36.98 110.677 58.854 157.03 65.625h7.033c16.145 0 26.822-9.896 32.03-29.688v114.844c0 7.812-5.99 11.72-17.968 11.72z"/>',
    paths: [{
      type: "positive",
      data: "M309.375 259.375c-50.52 0-110.938-22.396-181.25-67.188C48.437 141.667-10.938 94.272-50 50V-68.75C0-3.125 60.417 52.083 131.25 96.875c58.333 36.98 110.677 58.854 157.03 65.625h7.033c16.145 0 26.822-9.896 32.03-29.688v114.844c0 7.812-5.99 11.72-17.968 11.72z"
    }],
    bounds: {
      x: 0,
      y: 0,
      width: 377.3429870605469,
      height: 328.1260070800781
    },
    origin: {
      x: 50,
      y: 68.75
    },
    align: "left"
  },
  Porrectus3: {
    svgSrc: '<path d="M309.375 355.78c-48.96-16.666-109.115-55.468-180.47-116.405C79.428 198.23 19.793 134.687-50 48.75V-70C20 40 94.104 103.79 135.25 148.063 190 200 230 230 288.28 258.906c4.168 2.083 8.334 3.125 12.5 3.125 12.5 0 21.355-10.937 26.564-32.81v114.06c0 9.376-3.386 14.063-10.156 14.064-2.084 0-4.688-.522-7.813-1.563z"/>',
    paths: [{
      type: "positive",
      data: "M309.375 355.78c-48.96-16.666-109.115-55.468-180.47-116.405C79.428 198.23 19.793 134.687-50 48.75V-70C20 40 94.104 103.79 135.25 148.063 190 200 230 230 288.28 258.906c4.168 2.083 8.334 3.125 12.5 3.125 12.5 0 21.355-10.937 26.564-32.81v114.06c0 9.376-3.386 14.063-10.156 14.064-2.084 0-4.688-.522-7.813-1.563z"
    }],
    bounds: {
      x: 0,
      y: 0,
      width: 377.343994140625,
      height: 427.3450012207031
    },
    origin: {
      x: 50,
      y: 70
    },
    align: "left"
  },
  Porrectus4: {
    svgSrc: '<path d="M350 453.438c-52.754-22.397-120-77.345-201.74-164.844C90.87 227.656 24.784 147.708-50 48.75V-70C-8.84-1.25 58.406 86.51 151.74 193.28c60.868 69.793 119.13 124.22 174.782 163.282 5.797 3.646 11.014 5.47 15.652 5.47 12.173 0 21.45-11.72 27.826-35.157V441.72c0 9.373-3.19 14.06-9.565 14.06-2.9 0-6.377-.78-10.435-2.342z"/>',
    paths: [{
      type: "positive",
      data: "M350 453.438c-52.754-22.397-120-77.345-201.74-164.844C90.87 227.656 24.784 147.708-50 48.75V-70C-8.84-1.25 58.406 86.51 151.74 193.28c60.868 69.793 119.13 124.22 174.782 163.282 5.797 3.646 11.014 5.47 15.652 5.47 12.173 0 21.45-11.72 27.826-35.157V441.72c0 9.373-3.19 14.06-9.565 14.06-2.9 0-6.377-.78-10.435-2.342z"
    }],
    bounds: {
      x: 0,
      y: 0,
      width: 420,
      height: 525.780029296875
    },
    origin: {
      x: 50,
      y: 70
    },
    align: "left"
  },
  PunctumCavum: {
    svgSrc: '<path d="M0-60.906c33.333 0 50 9.635 50 28.906v94.53C39.062 51.595 22.396 46.126 0 46.126s-39.063 5.47-50 16.406V-32c0-19.27 16.667-28.906 50-28.906z"/><path fill="#fff" d="M.08-42.56c9.585.206 20.126.53 27.954 6.822 4.96 3.9 4.71 10.792 4.574 16.482v51.278C22.09 27.066 7.283 26.072.168 26.01c-7.72.23-21.895.935-32.616 4.674.04-19.197-.083-38.395.064-57.59.567-7.5 7.834-12.33 14.62-13.774 5.818-1.498 11.857-1.86 17.844-1.88z"/>',
    paths: [
      {
        type: "positive",
        data: "M0-60.906c33.333 0 50 9.635 50 28.906v94.53C39.062 51.595 22.396 46.126 0 46.126s-39.063 5.47-50 16.406V-32c0-19.27 16.667-28.906 50-28.906z"
      },
      {
        type: "negative",
        data: "M.08-42.56c9.585.206 20.126.53 27.954 6.822 4.96 3.9 4.71 10.792 4.574 16.482v51.278C22.09 27.066 7.283 26.072.168 26.01c-7.72.23-21.895.935-32.616 4.674.04-19.197-.083-38.395.064-57.59.567-7.5 7.834-12.33 14.62-13.774 5.818-1.498 11.857-1.86 17.844-1.88z"
      }
    ],
    bounds: {
      x: 0,
      y: 0,
      width: 100,
      height: 123.43799591064453
    },
    origin: {
      x: 50,
      y: 60.90599822998047
    },
    align: "left"
  },
  PunctumQuadratum: {
    svgSrc: '<path d="M0-60.906c33.333 0 50 9.635 50 28.906v94.53C39.062 51.595 22.396 46.126 0 46.126s-39.063 5.47-50 16.406V-32c0-19.27 16.667-28.906 50-28.906z"/>',
    paths: [{
      type: "positive",
      data: "M0-60.906c33.333 0 50 9.635 50 28.906v94.53C39.062 51.595 22.396 46.126 0 46.126s-39.063 5.47-50 16.406V-32c0-19.27 16.667-28.906 50-28.906z"
    }],
    bounds: {
      x: 0,
      y: 0,
      width: 100,
      height: 123.43799591064453
    },
    origin: {
      x: 50,
      y: 60.90599822998047
    },
    align: "left"
  },
  PunctumQuadratumAscLiquescent: {
    svgSrc: '<path d="M-50 43.688V-61c4.167 7.292 12.76 10.938 25.78 10.938 9.376 0 20.053-1.563 32.032-4.688C31.773-60.48 45.833-71.677 50-88.344v117.97C43.75 42.645 32.812 51.5 17.187 56.186-.52 61.398-15.886 64-28.906 64-42.97 64-50 57.23-50 43.687z"/>',
    paths: [{
      type: "positive",
      data: "M-50 43.688V-61c4.167 7.292 12.76 10.938 25.78 10.938 9.376 0 20.053-1.563 32.032-4.688C31.773-60.48 45.833-71.677 50-88.344v117.97C43.75 42.645 32.812 51.5 17.187 56.186-.52 61.398-15.886 64-28.906 64-42.97 64-50 57.23-50 43.687z"
    }],
    bounds: {
      x: 0,
      y: 0,
      width: 100,
      height: 152.343994140625
    },
    origin: {
      x: 50,
      y: 88.34400177001953
    },
    align: "left"
  },
  PunctumQuadratumDesLiquescent: {
    svgSrc: '<path d="M-50-56.03c0-13.022 7.03-19.532 21.094-19.532 13.02 0 28.385 2.604 46.093 7.812C32.813-63.583 43.75-54.73 50-41.187V76C45.833 59.854 31.77 48.656 7.812 42.406c-11.98-3.125-22.656-4.687-32.03-4.687-13.022 0-21.615 3.905-25.782 11.718v-105.47z"/>',
    paths: [{
      type: "positive",
      data: "M-50-56.03c0-13.022 7.03-19.532 21.094-19.532 13.02 0 28.385 2.604 46.093 7.812C32.813-63.583 43.75-54.73 50-41.187V76C45.833 59.854 31.77 48.656 7.812 42.406c-11.98-3.125-22.656-4.687-32.03-4.687-13.022 0-21.615 3.905-25.782 11.718v-105.47z"
    }],
    bounds: {
      x: 0,
      y: 0,
      width: 100,
      height: 151.56199645996094
    },
    origin: {
      x: 50,
      y: 75.56199645996094
    },
    align: "left"
  },
  PunctumInclinatum: {
    svgSrc: '<path d="M0-75.78L50 0 0 75-50 0 0-75.78z"/>',
    paths: [{
      type: "positive",
      data: "M0-75.78L50 0 0 75-50 0 0-75.78z"
    }],
    bounds: {
      x: 0,
      y: 0,
      width: 100,
      height: 150.77999877929688
    },
    origin: {
      x: 50,
      y: 75.77999877929688
    },
    align: "left"
  },
  PunctumInclinatumLiquescent: {
    svgSrc: '<path d="M 0,-53.164062 35,-0.1171875 0,52.382812 -35,-0.1171875 0,-53.164062 z"/>',
    paths: [{
      type: "positive",
      data: "M 0,-53.164062 35,-0.1171875 0,52.382812 -35,-0.1171875 0,-53.164062 z"
    }],
    bounds: {
      x: 0,
      y: 0,
      width: 70,
      height: 105.546
    },
    origin: {
      x: 35,
      y: 53.164062
    },
    align: "left"
  },
  Quilisma: {
    svgSrc: '<path d="M-50 34.938V-51c5.73 20.833 13.02 31.25 21.875 31.25 7.813 0 12.5-15.625 14.063-46.875 3.645 12.5 6.9 21.224 9.765 26.172s6.9 7.422 12.11 7.422c5.208 0 9.374-14.324 12.5-42.97 5.73 22.917 10.677 34.375 14.843 34.375 5.73 0 10.677-15.885 14.844-47.656v100c0 17.707-3.125 26.56-9.375 26.56-4.688 0-9.115-5.988-13.28-17.968-2.085 21.875-8.074 32.813-17.97 32.813-7.813 0-16.146-7.292-25-21.875-4.688 20.312-10.677 30.47-17.97 30.47-5.207 0-9.244-2.605-12.108-7.814C-48.568 47.698-50 41.708-50 34.938z"/>',
    paths: [{
      type: "positive",
      data: "M-50 34.938V-51c5.73 20.833 13.02 31.25 21.875 31.25 7.813 0 12.5-15.625 14.063-46.875 3.645 12.5 6.9 21.224 9.765 26.172s6.9 7.422 12.11 7.422c5.208 0 9.374-14.324 12.5-42.97 5.73 22.917 10.677 34.375 14.843 34.375 5.73 0 10.677-15.885 14.844-47.656v100c0 17.707-3.125 26.56-9.375 26.56-4.688 0-9.115-5.988-13.28-17.968-2.085 21.875-8.074 32.813-17.97 32.813-7.813 0-16.146-7.292-25-21.875-4.688 20.312-10.677 30.47-17.97 30.47-5.207 0-9.244-2.605-12.108-7.814C-48.568 47.698-50 41.708-50 34.938z"
    }],
    bounds: {
      x: 0,
      y: 0,
      width: 100,
      height: 150
    },
    origin: {
      x: 50,
      y: 89.28199768066406
    },
    align: "left"
  },
  TerminatingAscLiquescent: {
    svgSrc: '<path d="M-9.375 40.22c0-11.98-4.948-17.97-14.844-17.97-10.936 0-19.53 3.646-25.78 10.938v-53.126c0-6.77 2.604-12.76 7.813-17.968 5.208-5.21 10.677-8.594 16.406-10.157 2.603-.52 5.207-.78 7.81-.78 3.647 0 7.032.78 10.157 2.343C-2.603-43.896 0-39.73 0-34V73.03h-9.375V40.22z"/>',
    paths: [{
      type: "positive",
      data: "M-9.375 40.22c0-11.98-4.948-17.97-14.844-17.97-10.936 0-19.53 3.646-25.78 10.938v-53.126c0-6.77 2.604-12.76 7.813-17.968 5.208-5.21 10.677-8.594 16.406-10.157 2.603-.52 5.207-.78 7.81-.78 3.647 0 7.032.78 10.157 2.343C-2.603-43.896 0-39.73 0-34V73.03h-9.375V40.22z"
    }],
    bounds: {
      x: 0,
      y: 0,
      width: 49.999000549316406,
      height: 121.87299346923828
    },
    origin: {
      x: 49.999000549316406,
      y: 48.842994689941406
    },
    align: "right"
  },
  TerminatingDesLiquescent: {
    svgSrc: '<path d="M-9.375-48.156V-80.97H0V26.845c0 5.73-2.604 9.896-7.813 12.5-3.125 1.562-6.51 2.343-10.156 2.343-2.603 0-5.207-.26-7.81-.78-5.73-1.563-11.2-4.95-16.407-10.157C-47.398 25.542-50 19.292-50 12v-52.344c6.25 7.292 14.844 10.938 25.78 10.938 9.897 0 14.845-6.25 14.845-18.75z"/>',
    paths: [{
      type: "positive",
      data: "M-9.375-48.156V-80.97H0V26.845c0 5.73-2.604 9.896-7.813 12.5-3.125 1.562-6.51 2.343-10.156 2.343-2.603 0-5.207-.26-7.81-.78-5.73-1.563-11.2-4.95-16.407-10.157C-47.398 25.542-50 19.292-50 12v-52.344c6.25 7.292 14.844 10.938 25.78 10.938 9.897 0 14.845-6.25 14.845-18.75z"
    }],
    bounds: {
      x: 0,
      y: 0,
      width: 50,
      height: 122.65800476074219
    },
    origin: {
      x: 50,
      y: 80.97000122070312
    },
    align: "right"
  },
  VerticalEpisemaAbove: {
    svgSrc: '<path d="M-8-80H8L4 0h-8l-4-80z"/>',
    paths: [{
      type: "positive",
      data: "M-8-80H8L4 0h-8l-4-80z"
    }],
    bounds: {
      x: 0,
      y: 0,
      width: 16,
      height: 80
    },
    origin: {
      x: 8,
      y: 80
    },
    align: "left"
  },
  VerticalEpisemaBelow: {
    svgSrc: '<path d="M-8 80H8L4 0h-8l-4 80z"/>',
    paths: [{
      type: "positive",
      data: "M-8 80H8L4 0h-8l-4 80z"
    }],
    bounds: {
      x: 0,
      y: 0,
      width: 16,
      height: 80
    },
    origin: {
      x: 8,
      y: 0
    },
    align: "left"
  },
  VirgaLong: {
    svgSrc: '<path d="M50-38v285.156c0 6.77-2.344 10.937-7.03 12.5-1.564 0-2.605-.78-3.126-2.344-.52-1.562-.782-10.156-.782-25.78V54.186C29.168 45.334 16.146 40.907 0 40.907c-22.917 0-39.583 5.208-50 15.624V-38c0-19.27 16.667-28.906 50-28.906S50-57.27 50-38z"/>',
    paths: [{
      type: "positive",
      data: "M50-38v285.156c0 6.77-2.344 10.937-7.03 12.5-1.564 0-2.605-.78-3.126-2.344-.52-1.562-.782-10.156-.782-25.78V54.186C29.168 45.334 16.146 40.907 0 40.907c-22.917 0-39.583 5.208-50 15.624V-38c0-19.27 16.667-28.906 50-28.906S50-57.27 50-38z"
    }],
    bounds: {
      x: 0,
      y: 0,
      width: 100,
      height: 326.56201171875
    },
    origin: {
      x: 50,
      y: 66.90599822998047
    },
    align: "left"
  },
  VirgaShort: {
    svgSrc: '<path d="M50-38v211.72c0 7.29-2.344 11.457-7.03 12.5-1.564 0-2.606-.783-3.126-2.345-.52-1.563-.782-10.156-.782-25.78V54.187C29.167 45.332 16.146 40.906 0 40.906c-22.917 0-39.583 5.21-50 15.625V-38c0-19.27 16.667-28.906 50-28.906S50-57.27 50-38z"/>',
    paths: [{
      type: "positive",
      data: "M50-38v211.72c0 7.29-2.344 11.457-7.03 12.5-1.564 0-2.606-.783-3.126-2.345-.52-1.563-.782-10.156-.782-25.78V54.187C29.167 45.332 16.146 40.906 0 40.906c-22.917 0-39.583 5.21-50 15.625V-38c0-19.27 16.667-28.906 50-28.906S50-57.27 50-38z"
    }],
    bounds: {
      x: 0,
      y: 0,
      width: 100,
      height: 253.12600708007812
    },
    origin: {
      x: 50,
      y: 66.90599822998047
    },
    align: "left"
  },
  Virgula: {
    svgSrc: '<path d="M8.178-55.66c0-22.137 12.092-33.2 36.287-33.2 11.835 0 23.53 5.66 35.108 16.98C91.15-60.547 96.94-41.766 96.94-15.534c0 53.515-31.646 87.487-94.937 101.895-2.048-2.06-3.077-5.146-3.077-9.273 0-1.03.247-1.8.76-2.316 42.71-19.027 64.075-41.678 64.075-67.92 0-11.322-2.325-20.326-6.945-27.016-4.62-6.69-9.52-11.052-14.676-13.11-5.147-2.048-11.836-3.85-20.07-5.403C12.81-39.707 8.18-45.37 8.18-55.66z"/>',
    paths: [{
      type: "positive",
      data: "M8.178-55.66c0-22.137 12.092-33.2 36.287-33.2 11.835 0 23.53 5.66 35.108 16.98C91.15-60.547 96.94-41.766 96.94-15.534c0 53.515-31.646 87.487-94.937 101.895-2.048-2.06-3.077-5.146-3.077-9.273 0-1.03.247-1.8.76-2.316 42.71-19.027 64.075-41.678 64.075-67.92 0-11.322-2.325-20.326-6.945-27.016-4.62-6.69-9.52-11.052-14.676-13.11-5.147-2.048-11.836-3.85-20.07-5.403C12.81-39.707 8.18-45.37 8.18-55.66z"
    }],
    bounds: {
      x: 0,
      y: 0,
      width: 98.01399993896484,
      height: 175.2209930419922
    },
    origin: {
      x: 1.0739939212799072,
      y: 88.86000061035156
    },
    align: "left"
  }
};
class Wt {
  constructor(t) {
    this.name = typeof t < "u" ? t : "<unknown>";
  }
  /**
   * @param {String} text The string to parsed into words.
   * @return {Word[]} the resulting parsed words from syllabification
   */
  syllabify(t) {
    var A = [];
    if (typeof t > "u" || t === "")
      return A;
    for (var e = t.split(/[\s]+/), s = 0, n = e.length; s < n; s++)
      A.push(this.syllabifyWord(e[s]));
    return A;
  }
}
class Kt extends Wt {
  /**
   * @constructs
   */
  constructor() {
    super("Latin"), this.diphthongs = ["ae", "au", "oe", "aé", "áu", "oé"], this.possibleDiphthongs = this.diphthongs.concat(["ei", "eu", "ui", "éi", "éu", "úi"]);
    var t = new Object();
    t.huius = ["hui", "us"], t.cuius = ["cui", "us"], t.huic = ["huic"], t.cui = ["cui"], t.hui = ["hui"], t.euge = ["eu", "ge"], t.seu = ["seu"], this.vowels = [
      "a",
      "e",
      "i",
      "o",
      "u",
      "á",
      "é",
      "í",
      "ó",
      "ú",
      "æ",
      "œ",
      "ǽ",
      // no accented œ in unicode?
      "y"
    ], this.vowelsThatMightBeConsonants = ["i", "u"], this.muteConsonantsAndF = ["b", "c", "d", "g", "p", "t", "f"], this.liquidConsonants = ["l", "r"];
  }
  // c must be lowercase!
  isVowel(t) {
    for (var A = 0, e = this.vowels.length; A < e; A++)
      if (this.vowels[A] === t)
        return !0;
    return !1;
  }
  isVowelThatMightBeConsonant(t) {
    for (var A = 0, e = this.vowelsThatMightBeConsonants.length; A < e; A++)
      if (this.vowelsThatMightBeConsonants[A] === t)
        return !0;
    return !1;
  }
  // substring should be a vowel and the character following
  isVowelActingAsConsonant(t) {
    return this.isVowelThatMightBeConsonant(t[0]) && this.isVowel(t[1]);
  }
  /**
   * f is not a mute consonant, but we lump it together for syllabification
   * since it is syntactically treated the same way
   *
   * @param {String} c The character to test; must be lowercase
   * @return {boolean} true if c is an f or a mute consonant
   */
  isMuteConsonantOrF(t) {
    for (var A = 0, e = this.muteConsonantsAndF.length; A < e; A++)
      if (this.muteConsonantsAndF[A] === t)
        return !0;
    return !1;
  }
  /**
   *
   * @param {String} c The character to test; must be lowercase
   * @return {boolean} true if c is a liquid consonant
   */
  isLiquidConsonant(t) {
    for (var A = 0, e = this.liquidConsonants.length; A < e; A++)
      if (this.liquidConsonants[A] === t)
        return !0;
    return !1;
  }
  /**
   *
   * @param {String} s The string to test; must be lowercase
   * @return {boolean} true if s is a diphthong
   */
  isDiphthong(t) {
    for (var A = 0, e = this.diphthongs.length; A < e; A++)
      if (this.diphthongs[A] === t)
        return !0;
    return !1;
  }
  /**
   *
   * @param {String} s The string to test; must be lowercase
   * @return {boolean} true if s is a diphthong
   */
  isPossibleDiphthong(t) {
    for (var A = 0, e = this.possibleDiphthongs.length; A < e; A++)
      if (this.possibleDiphthongs[A] === t)
        return !0;
    return !1;
  }
  /**
   * Rules for Latin syllabification (from Collins, "A Primer on Ecclesiastical Latin")
   *
   * Divisions occur when:
   *   1. After open vowels (those not followed by a consonant) (e.g., "pi-us" and "De-us")
   *   2. After vowels followed by a single consonant (e.g., "vi-ta" and "ho-ra")
   *   3. After the first consonant when two or more consonants follow a vowel
   *      (e.g., "mis-sa", "minis-ter", and "san-ctus").
   *
   * Exceptions:
   *   1. In compound words the consonants stay together (e.g., "de-scribo").
   *   2. A mute consonant (b, c, d, g, p, t) or f followed by a liquid consonant (l, r)
   *      go with the succeeding vowel: "la-crima", "pa-tris"
   *
   * In addition to these rules, Wheelock's Latin provides this sound exception:
   *   -  Also counted as single consonants are qu and the aspirates ch, ph,
   *      th, which should never be separated in syllabification:
   *      architectus, ar-chi-tec-tus; loquacem, lo-qua-cem.
   *
   */
  syllabifyWord(t) {
    for (var A = [], e = !1, s = !1, n = t.toLowerCase(), a = 0, r, c, g, h = function(v) {
      e && (A.push(t.substr(a, v)), a += v), e = !1;
    }, f = 0, d = n.length; f < d; f++) {
      r = n[f], c = "*", g = f + 1 < d, g && (c = n[f + 1]);
      var B = this.isVowel(r);
      r === "i" && (f === 0 && g && this.isVowel(c) || s && g && this.isVowel(c)) && (B = !1), r === "-" ? (e = !0, s = !1, h(f - a), a++) : B ? (e = !0, s && !this.isDiphthong(n[f - 1] + "" + r) && (h(f - a), e = !0), s = !0) : g && (r === "q" && c === "u" || c === "h" && (r === "c" || r === "p" || r === "t") ? (h(f - a), f++) : s && this.isVowel(c) || this.isMuteConsonantOrF(r) && this.isLiquidConsonant(c) ? h(f - a) : e && h(f + 1 - a), s = !1);
    }
    return e ? A.push(t.substr(a)) : a > 0 && (A[A.length - 1] += t.substr(a)), A;
  }
  /**
   * @param {String} s the string to search
   * @param {Number} startIndex The index at which to start searching for a vowel in the string
   * @retuns a custom class with three properties: {found: (true/false) startIndex: (start index in s of vowel segment) length ()}
   */
  findVowelSegment(t, A) {
    var e, s, n, a = t.toLowerCase();
    for (e = 0, s = this.possibleDiphthongs.length; e < s; e++) {
      var r = this.possibleDiphthongs[e];
      if (n = a.indexOf(r, A), n >= 0)
        return { found: !0, startIndex: n, length: r.length };
    }
    for (e = 0, s = this.vowels.length; e < s; e++)
      if (n = a.indexOf(this.vowels[e], A), n >= 0)
        return this.isVowelActingAsConsonant(a.substr(n, 2)) && ++n, { found: !0, startIndex: n, length: 1 };
    return { found: !1, startIndex: -1, length: -1 };
  }
}
class VA extends Wt {
  constructor() {
    super("Spanish"), this.vowels = [
      "a",
      "e",
      "i",
      "o",
      "u",
      "y",
      "á",
      "é",
      "í",
      "ó",
      "ú",
      "ü"
    ], this.weakVowels = ["i", "u", "ü", "y"], this.strongVowels = ["a", "e", "o", "á", "é", "í", "ó", "ú"], this.diphthongs = [
      "ai",
      "ei",
      "oi",
      "ui",
      "ia",
      "ie",
      "io",
      "iu",
      "au",
      "eu",
      "ou",
      "ua",
      "ue",
      "uo",
      "ái",
      "éi",
      "ói",
      "úi",
      "iá",
      "ié",
      "ió",
      "iú",
      "áu",
      "éu",
      "óu",
      "uá",
      "ué",
      "uó",
      "üe",
      "üi"
    ], this.uDiphthongExceptions = ["gue", "gui", "qua", "que", "qui", "quo"];
  }
  // c must be lowercase!
  isVowel(t) {
    for (var A = 0, e = this.vowels.length; A < e; A++)
      if (this.vowels[A] === t)
        return !0;
    return !1;
  }
  /**
   * @param {String} c The character to test; must be lowercase
   * @return {boolean} true if c is an f or a mute consonant
   */
  isWeakVowel(t) {
    for (var A = 0, e = this.weakVowels.length; A < e; A++)
      if (this.weakVowels[A] === t)
        return !0;
    return !1;
  }
  /**
   * @param {String} c The character to test; must be lowercase
   * @return {boolean} true if c is an f or a mute consonant
   */
  isStrongVowel(t) {
    for (var A = 0, e = this.strongVowels.length; A < e; A++)
      if (this.strongVowels[A] === t)
        return !0;
    return !1;
  }
  /**
   *
   * @param {String} s The string to test; must be lowercase
   * @return {boolean} true if s is a diphthong
   */
  isDiphthong(t) {
    for (var A = 0, e = this.diphthongs.length; A < e; A++)
      if (this.diphthongs[A] === t)
        return !0;
    return !1;
  }
  createSyllable(t) {
    return t;
  }
  /**
   */
  syllabifyWord(t) {
    var A = [], e = !1, s = !1, n = !1, a = 0;
    for (i = 0; i < t.length; i++) {
      var r = t[i].toLowerCase();
      if (this.isVowel(r)) {
        e = !0;
        var c = this.isStrongVowel(r);
        s && c && n && (A.push(this.createSyllable(t.substr(a, i - a))), a = i), s = !0, n = c;
      } else {
        if (e) {
          if (t[i] === "-")
            A.push(this.createSyllable(t.substr(a, i - a))), a = ++i;
          else {
            var g = 1, h;
            for (j = i + 1; j < t.length && !this.isVowel(t[j]); j++)
              g++;
            g === 1 ? (A.push(this.createSyllable(t.substr(a, i - a))), a = i) : g === 2 ? (h = t[i + 1].toLowerCase(), h === "l" || h === "r" || r === "c" && h === "h" ? (A.push(this.createSyllable(t.substr(a, i - a))), a = i++) : (A.push(this.createSyllable(t.substr(a, ++i - a))), a = i)) : g === 3 ? (h = t[i + 1].toLowerCase(), h === "s" ? (i += 2, A.push(this.createSyllable(t.substr(a, i - a)))) : A.push(this.createSyllable(t.substr(a, ++i - a))), a = i) : g === 4 && (A.push(this.createSyllable(t.substr(a, i - a + 2))), a = i + 2, i += 3);
          }
          e = !1;
        }
        s = !1;
      }
    }
    return e ? A.push(t.substr(a)) : a > 0 ? A[A.length - 1] += t.substr(a) : A.length === 0 && A.push(this.createSyllable(t)), A;
  }
  /**
   * @param {String} s the string to search
   * @param {Number} startIndex The index at which to start searching for a vowel in the string
   * @retuns a custom class with three properties: {found: (true/false) startIndex: (start index in s of vowel segment) length ()}
   */
  findVowelSegment(t, A) {
    var e, s, n, a = t.toLowerCase();
    for (e = 0, s = this.diphthongs.length; e < s; e++) {
      var r = this.diphthongs[e];
      if (n = a.indexOf(r, A), n >= 0) {
        if (r[0] === "u" && n > 0) {
          var c = t.substr(n - 1, 3).toLowerCase();
          for (j = 0, endj = this.uDiphthongExceptions.length; e < endj; j++)
            if (c === this.uDiphthongExceptions[j])
              return this.findVowelSegment(t, n + 1);
        }
        return { found: !0, startIndex: n, length: r.length };
      }
    }
    for (e = 0, s = this.vowels.length; e < s; e++)
      if (n = a.indexOf(this.vowels[e], A), n >= 0)
        return { found: !0, startIndex: n, length: 1 };
    return { found: !1, startIndex: -1, length: -1 };
  }
}
const jt = "data:font/otf;base64,AAEAAAATAQAABAAwRFNJRwAAAAEAAENkAAAACEdERUYAbgADAABDbAAAABhHUE9TTxtiswAAQ4QAAAE8R1NVQjtgWB4AAETAAAAAlk9TLzJKLTibAAABuAAAAGBjbWFwCRIK1gAAA4gAAAEEY3Z0IAGGB0cAAAZ0AAAAGmZwZ20GWZw3AAAEjAAAAXNnYXNwABcACAAAQ1QAAAAQZ2x5ZhRQNO4AAAdQAAAEzGhlYWQKMl2QAAABPAAAADZoaGVhDC0CmQAAAXQAAAAkaG10eB67AO4AAAIYAAABbmtlcm4E1wS9AAAMHAAAAMZsb2NhLQ4u0gAABpAAAADAbWF4cAJtAJoAAAGYAAAAIG5hbWUmgJC3AAAM5AAANY5wb3N0CJUJxAAAQnQAAADgcHJlcNTHuIYAAAYAAAAAcgABAAAAAQAArr24P18PPPUAGwgAAAAAANLrfC8AAAAA0uuXUgAA/vAFLAYhAAAACQACAAAAAAAAAAEAAAb+/bwAAAUzAAD/UQUsAAEAAAAAAAAAAAAAAAAAAABYAAEAAABfAE4AAwAAAAAAAQAAAAAACgAAAgAASwAAAAAAAwNBAZAABQAAA1gDWAAABLADWANYAAAEsABkAfQAAAIABQMGAAACAAQAAAABAAAAAAAAAAAAAAAAICAgIABAACEAfgb+/bwAAAb+AkQAAAABAAAAAAOiBOwAAAAgAAIDMwAAAzMAAAMzAAADMwAAAzMAAAMzAAADMwAAAzMAAAMzAAADMwAAAzMAAAMzAAADMwAAAzMAAAHVAIMDMwAAAzMAAAMzAAADMwAAAzMAAAMzAAADMwAAAzMAAAMzAAADMwAAAzMAAAMzAAADMwAAAzMAAAMzAAADMwAAAzMAAAMzAAAEwwAAAzMAAAMzAAADMwAAAzMAAAMzAAADMwAAAzMAAAMzAAADMwAAAzMAAAMzAAADMwAAAzMAAAMzAAADMwAAAzMAAAR9ACkDMwAAAzMAAAMzAAAFMwAUAzMAAAMzAAADMwAAAzMAAAMzAAADMwAAAzMAAAMzAAADMwAAAzMAAAO6AAADMwAAAzMAAAMzAAADMwAAAzMAAAMzAAADMwAAAzMAAAMzAAADMwAAAzMAAAMzAAADMwAAAzMAAAMzAAADMwAAA4kAHwMzAAADMwAAAzMAAAQNAA8DMwAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAADAAAAHAABAAAAAAA8AAMAAQAAABwABAAgAAAABAAEAAEAAAB+//8AAAAg////4AABAAAAAAAGAMgAAAAgAF8AAAABAAIAAwAEAAUABgAHAAgACQAKAAsADAANAA4ADwAQABEAEgATABQAFQAWABcAGAAZABoAGwAcAB0AHgAfACAAIQAiACMAJAAlACYAJwAoACkAKgArACwALQAuAC8AMAAxADIAMwA0ADUANgA3ADgAOQA6ADsAPAA9AD4APwBAAEEAQgBDAEQARQBGAEcASABJAEoASwBMAE0ATgBPAFAAUQBSAFMAVABVAFYAVwBYAFkAWgBbAFwAXQBeuAAALEu4AAlQWLEBAY5ZuAH/hbgARB25AAkAA19eLbgAASwgIEVpRLABYC24AAIsuAABKiEtuAADLCBGsAMlRlJYI1kgiiCKSWSKIEYgaGFksAQlRiBoYWRSWCNlilkvILAAU1hpILAAVFghsEBZG2kgsABUWCGwQGVZWTotuAAELCBGsAQlRlJYI4pZIEYgamFksAQlRiBqYWRSWCOKWS/9LbgABSxLILADJlBYUViwgEQbsEBEWRshISBFsMBQWLDARBshWVktuAAGLCAgRWlEsAFgICBFfWkYRLABYC24AAcsuAAGKi24AAgsSyCwAyZTWLBAG7AAWYqKILADJlNYIyGwgIqKG4ojWSCwAyZTWCMhuADAioobiiNZILADJlNYIyG4AQCKihuKI1kgsAMmU1gjIbgBQIqKG4ojWSC4AAMmU1iwAyVFuAGAUFgjIbgBgCMhG7ADJUUjISMhWRshWUQtuAAJLEtTWEVEGyEhWS0AuAAAKwC6AAEAAgACKwG6AAMAAgACKwG/AAMATAA8AC8AIgAUAAAACCu/AAQARwA8AC8AIgAUAAAACCsAvwABAIAAZgBQADkAIgAAAAgrvwACAHgAZgBQADkAIgAAAAgrALoABQAEAAcruAAAIEV9aRhEAAAAKgArAFAAbgCCAAAAHv4gABQDogAeBOwAOQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEIAQgBCAEIAQgBCAEIAQgBCAEIAQgBCAEIAQgBCAEIAQgBCAEIAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAQwBDAEMAQwBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAagBqAGoAagBqAGoAagBqAGoAagBqAGoAagBqAGoAagBqAIcAhwCHAIcAmYCZgJmAmYCZgJmAmYCZgJmAAEAg//YAXEA7AAPAEu7AAAABAAIAAQrQRMABgAAABYAAAAmAAAANgAAAEYAAABWAAAAZgAAAHYAAACGAAAACV1BBQCVAAAApQAAAAJdALoADQAFAAMrMDElFA4CIyImNTQ+AjMyFgFxFSUzHTYuFiYzHDIxeyM7LBk6NiI7LRo7AAAAAAMAAP72BK4GIQACAB4ALAAAAQsBBwMGFhcVITU+ATcBPgE3AR4DFxUhNT4BJwMCFjcGJjcBLgEHNhYDAQL2sKsebwpKUv5gRFAKAXQXRBoBpAUSHi4g/lpOPAtyoi1ecrRIAdcBRVR70VX+OQIXAgL9/lr+sh8cCSsrDBoeBGYZKQ77Sg4WEAwEKysFHiEBTv3MDQSKE+8FHkMMCsZJ/vn7AwAAAwAp/vAFLAYbADEAPwBNAAAzNT4BNREOAQcnPgMzMh4CFRQOAgcBHgM3Fw4BIyImJwEGKwEiJicRFBYXFQMiBxEeATMyNjU0LgISFjcGJjcBLgEHNhYDATJETSNJJQkvYGhzQnSscjgpS2g+AS8PIys1IgtCdycdNw7+0Q0NGxo0HEhJRCYnGygWnqonU4HtLV5ytEgB1wFFVHvRVf45Kw4hDgQ9BQsFPgwVEQouUm9ASHVaQBP+GhYaDQEDKxYdIBcCMQIFBv4FDCMOKwS2A/4ABQKLhTdcQiX6zQ0EihPvBR5DDArGSf75+wMAAAAAAgAU/vYFCgYhABoAKAAAAQ4BBwEOAwcBLgEnNSEVDgEXCQE2Jic1IQAWNwYmNwEuAQc2FgMBBQpETQr+gQgnLiwN/kgKRT8Bs1A7CwFhAVALR1IBoPxdLV5ytEgB1wFFVHvRVf45BMENGRz7vBYfFQwDBJ0aIAgrKwYdHfxKA7QdGwor+p0NBIoT7wUeQwwKxkn++fsDAAADAAD/LwOrBOUAAgAeACwAAAELAQ8BBhYXFSE1PgE3AT4BNwEeAxcVITU+AS8BAhY3BiY3ATQmBzYWBwECNGtpHlAFKEv+oEAxBgEXFTYtAUIDCxAeJ/6bRx8GU3oOZGuBOQFhIV1xlUL+qgG5AUf+uV76ERAJNzYMEREDcBciGfw+CQ4JCAU3OAUQFPr+WwUFhxPFA/0rBgy8RNX8HAAAAwAf/y8D6wTlADEAPwBNAAAzNT4BNREiBgcnPgMzMh4CFRQOAgcTHgM3Fw4BIyImJwM2KwEiJhcRFBYXFQMiBxEeATMyNjU0LgISFjcGJjcBNCYHNhYHASc+LgI3MQoxSk9ZM1uIXCwfO1Mi3goVGCIsDT9eIR0zDN4GDBQVKgMrQkcbCwQbEG11HDhYqw5ka4E5AWEhXXGVQv6qNg0VBQM/CQdHDRENCCZFWjM5Xkk1C/6ODxEHAQQ1FhgfFQGqAQQB/oYEFg02A60B/oQBAWNlKkQuG/wJBQWHE8UD/SsGDLxE1fwcAAIAD/8vA/AE5QAaACgAAAEOAQcBDgMHAS4BJzUhFQ4BFxsBNiYnNSEAFjcGJjcBNCYHNhYHAQPwQDAF/uEHIickH/6xBio7AW5IHgb16AYmSgFg/TIOZGuBOQFhIV1xlUL+qgO5DRAQ/KwTHRIKCAOoEBQINzgGDxH9UwKrEA8KN/vHBQWHE8UD/SsGDLxE1fwcAAAAAAEAAADCAAEAHgBgAAQAVAAhAA7/nAAhACEANgAhADIADQAhADb/8gAhAEEANgAhAFIAFwAhAFb/pQAyAA7/nAAyACEAWAAyADIAoQAyADYAvQAyAEEAWAAyAFIATwAyAFYAaQA2AA7+cAA2ACH+kwA2ADL/+QA2ADYADgA2AEH+kwA2AFL/YQA2AFb/fABBAA7/nABBAFIAFwBBAFb/1QBSAA7/nABSAFIANgBSAFYATABWAA7+cABWAFIACQBWAFYAGQAAAAAAFAD2AAEAAAAAAAAALgAAAAEAAAAAAAEAEgA1AAEAAAAAAAIABwAuAAEAAAAAAAMAHwA1AAEAAAAAAAQAEgA1AAEAAAAAAAUALwBUAAEAAAAAAAYAEQCDAAEAAAAAAA0Q9ACUAAEAAAAAAA4AGgEkAAEAAAAAABIAEgA1AAMAAQQJAAAAXBGIAAMAAQQJAAEAJBHyAAMAAQQJAAIADhHkAAMAAQQJAAMAPhHyAAMAAQQJAAQAJBHyAAMAAQQJAAUAXhIwAAMAAQQJAAYAIhKOAAMAAQQJAA0h6BKwAAMAAQQJAA4ANBPQAAMAAQQJABIAJBHyQ29weXJpZ2h0IChjKSAyMDE2IEZyLiBNYXR0aGV3IFNwZW5jZXIsIE8uUy5KLlJlZ3VsYXJFeHN1cmdlIENoYXJhY3RlcnM6VmVyc2lvbiAxLjAwVmVyc2lvbiAxLjAwIEZlYnJ1YXJ5IDE4LCAyMDE2LCBpbml0aWFsIHJlbGVhc2VFeHN1cmdlQ2hhcmFjdGVyc1RoaXMgRm9udCBTb2Z0d2FyZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgU0lMIE9wZW4gRm9udCBMaWNlbnNlLCBWZXJzaW9uIDEuMS4gVGhpcyBsaWNlbnNlIGlzIGNvcGllZCBiZWxvdywgYW5kIGlzIGFsc28gYXZhaWxhYmxlIHdpdGggYSBGQVEgYXQ6IGh0dHA6Ly9zY3JpcHRzLnNpbC5vcmcvT0ZMDQoNCg0KLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0NClNJTCBPUEVOIEZPTlQgTElDRU5TRSBWZXJzaW9uIDEuMSAtIDI2IEZlYnJ1YXJ5IDIwMDcNCi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tDQoNClBSRUFNQkxFDQpUaGUgZ29hbHMgb2YgdGhlIE9wZW4gRm9udCBMaWNlbnNlIChPRkwpIGFyZSB0byBzdGltdWxhdGUgd29ybGR3aWRlIGRldmVsb3BtZW50IG9mIGNvbGxhYm9yYXRpdmUgZm9udCBwcm9qZWN0cywgdG8gc3VwcG9ydCB0aGUgZm9udCBjcmVhdGlvbiBlZmZvcnRzIG9mIGFjYWRlbWljIGFuZCBsaW5ndWlzdGljIGNvbW11bml0aWVzLCBhbmQgdG8gcHJvdmlkZSBhIGZyZWUgYW5kIG9wZW4gZnJhbWV3b3JrIGluIHdoaWNoIGZvbnRzIG1heSBiZSBzaGFyZWQgYW5kIGltcHJvdmVkIGluIHBhcnRuZXJzaGlwIHdpdGggb3RoZXJzLg0KDQpUaGUgT0ZMIGFsbG93cyB0aGUgbGljZW5zZWQgZm9udHMgdG8gYmUgdXNlZCwgc3R1ZGllZCwgbW9kaWZpZWQgYW5kIHJlZGlzdHJpYnV0ZWQgZnJlZWx5IGFzIGxvbmcgYXMgdGhleSBhcmUgbm90IHNvbGQgYnkgdGhlbXNlbHZlcy4gVGhlIGZvbnRzLCBpbmNsdWRpbmcgYW55IGRlcml2YXRpdmUgd29ya3MsIGNhbiBiZSBidW5kbGVkLCBlbWJlZGRlZCwgcmVkaXN0cmlidXRlZCBhbmQvb3Igc29sZCB3aXRoIGFueSBzb2Z0d2FyZSBwcm92aWRlZCB0aGF0IGFueSByZXNlcnZlZCBuYW1lcyBhcmUgbm90IHVzZWQgYnkgZGVyaXZhdGl2ZSB3b3Jrcy4gVGhlIGZvbnRzIGFuZCBkZXJpdmF0aXZlcywgaG93ZXZlciwgY2Fubm90IGJlIHJlbGVhc2VkIHVuZGVyIGFueSBvdGhlciB0eXBlIG9mIGxpY2Vuc2UuIFRoZSByZXF1aXJlbWVudCBmb3IgZm9udHMgdG8gcmVtYWluIHVuZGVyIHRoaXMgbGljZW5zZSBkb2VzIG5vdCBhcHBseSB0byBhbnkgZG9jdW1lbnQgY3JlYXRlZCB1c2luZyB0aGUgZm9udHMgb3IgdGhlaXIgZGVyaXZhdGl2ZXMuDQoNCkRFRklOSVRJT05TDQoiRm9udCBTb2Z0d2FyZSIgcmVmZXJzIHRvIHRoZSBzZXQgb2YgZmlsZXMgcmVsZWFzZWQgYnkgdGhlIENvcHlyaWdodCBIb2xkZXIocykgdW5kZXIgdGhpcyBsaWNlbnNlIGFuZCBjbGVhcmx5IG1hcmtlZCBhcyBzdWNoLiBUaGlzIG1heSBpbmNsdWRlIHNvdXJjZSBmaWxlcywgYnVpbGQgc2NyaXB0cyBhbmQgZG9jdW1lbnRhdGlvbi4NCg0KIlJlc2VydmVkIEZvbnQgTmFtZSIgcmVmZXJzIHRvIGFueSBuYW1lcyBzcGVjaWZpZWQgYXMgc3VjaCBhZnRlciB0aGUgY29weXJpZ2h0IHN0YXRlbWVudChzKS4NCg0KIk9yaWdpbmFsIFZlcnNpb24iIHJlZmVycyB0byB0aGUgY29sbGVjdGlvbiBvZiBGb250IFNvZnR3YXJlIGNvbXBvbmVudHMgYXMgZGlzdHJpYnV0ZWQgYnkgdGhlIENvcHlyaWdodCBIb2xkZXIocykuDQoNCiJNb2RpZmllZCBWZXJzaW9uIiByZWZlcnMgdG8gYW55IGRlcml2YXRpdmUgbWFkZSBieSBhZGRpbmcgdG8sIGRlbGV0aW5nLCBvciBzdWJzdGl0dXRpbmcgLS0gaW4gcGFydCBvciBpbiB3aG9sZSAtLSBhbnkgb2YgdGhlIGNvbXBvbmVudHMgb2YgdGhlIE9yaWdpbmFsIFZlcnNpb24sIGJ5IGNoYW5naW5nIGZvcm1hdHMgb3IgYnkgcG9ydGluZyB0aGUgRm9udCBTb2Z0d2FyZSB0byBhIG5ldyBlbnZpcm9ubWVudC4NCg0KIkF1dGhvciIgcmVmZXJzIHRvIGFueSBkZXNpZ25lciwgZW5naW5lZXIsIHByb2dyYW1tZXIsIHRlY2huaWNhbCB3cml0ZXIgb3Igb3RoZXIgcGVyc29uIHdobyBjb250cmlidXRlZCB0byB0aGUgRm9udCBTb2Z0d2FyZS4NCg0KUEVSTUlTU0lPTiAmIENPTkRJVElPTlMNClBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHkgb2YgdGhlIEZvbnQgU29mdHdhcmUsIHRvIHVzZSwgc3R1ZHksIGNvcHksIG1lcmdlLCBlbWJlZCwgbW9kaWZ5LCByZWRpc3RyaWJ1dGUsIGFuZCBzZWxsIG1vZGlmaWVkIGFuZCB1bm1vZGlmaWVkIGNvcGllcyBvZiB0aGUgRm9udCBTb2Z0d2FyZSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6DQoNCjEpIE5laXRoZXIgdGhlIEZvbnQgU29mdHdhcmUgbm9yIGFueSBvZiBpdHMgaW5kaXZpZHVhbCBjb21wb25lbnRzLCBpbiBPcmlnaW5hbCBvciBNb2RpZmllZCBWZXJzaW9ucywgbWF5IGJlIHNvbGQgYnkgaXRzZWxmLg0KDQoyKSBPcmlnaW5hbCBvciBNb2RpZmllZCBWZXJzaW9ucyBvZiB0aGUgRm9udCBTb2Z0d2FyZSBtYXkgYmUgYnVuZGxlZCwgcmVkaXN0cmlidXRlZCBhbmQvb3Igc29sZCB3aXRoIGFueSBzb2Z0d2FyZSwgcHJvdmlkZWQgdGhhdCBlYWNoIGNvcHkgY29udGFpbnMgdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgbGljZW5zZS4gVGhlc2UgY2FuIGJlIGluY2x1ZGVkIGVpdGhlciBhcyBzdGFuZC1hbG9uZSB0ZXh0IGZpbGVzLCBodW1hbi1yZWFkYWJsZSBoZWFkZXJzIG9yIGluIHRoZSBhcHByb3ByaWF0ZSBtYWNoaW5lLXJlYWRhYmxlIG1ldGFkYXRhIGZpZWxkcyB3aXRoaW4gdGV4dCBvciBiaW5hcnkgZmlsZXMgYXMgbG9uZyBhcyB0aG9zZSBmaWVsZHMgY2FuIGJlIGVhc2lseSB2aWV3ZWQgYnkgdGhlIHVzZXIuDQoNCjMpIE5vIE1vZGlmaWVkIFZlcnNpb24gb2YgdGhlIEZvbnQgU29mdHdhcmUgbWF5IHVzZSB0aGUgUmVzZXJ2ZWQgRm9udCBOYW1lKHMpIHVubGVzcyBleHBsaWNpdCB3cml0dGVuIHBlcm1pc3Npb24gaXMgZ3JhbnRlZCBieSB0aGUgY29ycmVzcG9uZGluZyBDb3B5cmlnaHQgSG9sZGVyLiBUaGlzIHJlc3RyaWN0aW9uIG9ubHkgYXBwbGllcyB0byB0aGUgcHJpbWFyeSBmb250IG5hbWUgYXMgcHJlc2VudGVkIHRvIHRoZSB1c2Vycy4NCg0KNCkgVGhlIG5hbWUocykgb2YgdGhlIENvcHlyaWdodCBIb2xkZXIocykgb3IgdGhlIEF1dGhvcihzKSBvZiB0aGUgRm9udCBTb2Z0d2FyZSBzaGFsbCBub3QgYmUgdXNlZCB0byBwcm9tb3RlLCBlbmRvcnNlIG9yIGFkdmVydGlzZSBhbnkgTW9kaWZpZWQgVmVyc2lvbiwgZXhjZXB0IHRvIGFja25vd2xlZGdlIHRoZSBjb250cmlidXRpb24ocykgb2YgdGhlIENvcHlyaWdodCBIb2xkZXIocykgYW5kIHRoZSBBdXRob3Iocykgb3Igd2l0aCB0aGVpciBleHBsaWNpdCB3cml0dGVuIHBlcm1pc3Npb24uDQoNCjUpIFRoZSBGb250IFNvZnR3YXJlLCBtb2RpZmllZCBvciB1bm1vZGlmaWVkLCBpbiBwYXJ0IG9yIGluIHdob2xlLCBtdXN0IGJlIGRpc3RyaWJ1dGVkIGVudGlyZWx5IHVuZGVyIHRoaXMgbGljZW5zZSwgYW5kIG11c3Qgbm90IGJlIGRpc3RyaWJ1dGVkIHVuZGVyIGFueSBvdGhlciBsaWNlbnNlLiBUaGUgcmVxdWlyZW1lbnQgZm9yIGZvbnRzIHRvIHJlbWFpbiB1bmRlciB0aGlzIGxpY2Vuc2UgZG9lcyBub3QgYXBwbHkgdG8gYW55IGRvY3VtZW50IGNyZWF0ZWQgdXNpbmcgdGhlIEZvbnQgU29mdHdhcmUuDQoNClRFUk1JTkFUSU9ODQpUaGlzIGxpY2Vuc2UgYmVjb21lcyBudWxsIGFuZCB2b2lkIGlmIGFueSBvZiB0aGUgYWJvdmUgY29uZGl0aW9ucyBhcmUgbm90IG1ldC4NCg0KRElTQ0xBSU1FUg0KVEhFIEZPTlQgU09GVFdBUkUgSVMgUFJPVklERUQgIkFTIElTIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIEFOWSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVCBPRiBDT1BZUklHSFQsIFBBVEVOVCwgVFJBREVNQVJLLCBPUiBPVEhFUiBSSUdIVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBIT0xERVIgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBJTkNMVURJTkcgQU5ZIEdFTkVSQUwsIFNQRUNJQUwsIElORElSRUNULCBJTkNJREVOVEFMLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgVEhFIFVTRSBPUiBJTkFCSUxJVFkgVE8gVVNFIFRIRSBGT05UIFNPRlRXQVJFIE9SIEZST00gT1RIRVIgREVBTElOR1MgSU4gVEhFIEZPTlQgU09GVFdBUkUuAEMAbwBwAHkAcgBpAGcAaAB0ACAAKABjACkAIAAyADAAMQA2ACAARgByAC4AIABNAGEAdAB0AGgAZQB3ACAAUwBwAGUAbgBjAGUAcgAsACAATwAuAFMALgBKAC4AUgBlAGcAdQBsAGEAcgBFAHgAcwB1AHIAZwBlACAAQwBoAGEAcgBhAGMAdABlAHIAcwA6AFYAZQByAHMAaQBvAG4AIAAxAC4AMAAwAFYAZQByAHMAaQBvAG4AIAAxAC4AMAAwACAARgBlAGIAcgB1AGEAcgB5ACAAMQA4ACwAIAAyADAAMQA2ACwAIABpAG4AaQB0AGkAYQBsACAAcgBlAGwAZQBhAHMAZQBFAHgAcwB1AHIAZwBlAEMAaABhAHIAYQBjAHQAZQByAHMAVABoAGkAcwAgAEYAbwBuAHQAIABTAG8AZgB0AHcAYQByAGUAIABpAHMAIABsAGkAYwBlAG4AcwBlAGQAIAB1AG4AZABlAHIAIAB0AGgAZQAgAFMASQBMACAATwBwAGUAbgAgAEYAbwBuAHQAIABMAGkAYwBlAG4AcwBlACwAIABWAGUAcgBzAGkAbwBuACAAMQAuADEALgAgAFQAaABpAHMAIABsAGkAYwBlAG4AcwBlACAAaQBzACAAYwBvAHAAaQBlAGQAIABiAGUAbABvAHcALAAgAGEAbgBkACAAaQBzACAAYQBsAHMAbwAgAGEAdgBhAGkAbABhAGIAbABlACAAdwBpAHQAaAAgAGEAIABGAEEAUQAgAGEAdAA6ACAAaAB0AHQAcAA6AC8ALwBzAGMAcgBpAHAAdABzAC4AcwBpAGwALgBvAHIAZwAvAE8ARgBMAA0ACgANAAoADQAKAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQANAAoAUwBJAEwAIABPAFAARQBOACAARgBPAE4AVAAgAEwASQBDAEUATgBTAEUAIABWAGUAcgBzAGkAbwBuACAAMQAuADEAIAAtACAAMgA2ACAARgBlAGIAcgB1AGEAcgB5ACAAMgAwADAANwANAAoALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAA0ACgANAAoAUABSAEUAQQBNAEIATABFAA0ACgBUAGgAZQAgAGcAbwBhAGwAcwAgAG8AZgAgAHQAaABlACAATwBwAGUAbgAgAEYAbwBuAHQAIABMAGkAYwBlAG4AcwBlACAAKABPAEYATAApACAAYQByAGUAIAB0AG8AIABzAHQAaQBtAHUAbABhAHQAZQAgAHcAbwByAGwAZAB3AGkAZABlACAAZABlAHYAZQBsAG8AcABtAGUAbgB0ACAAbwBmACAAYwBvAGwAbABhAGIAbwByAGEAdABpAHYAZQAgAGYAbwBuAHQAIABwAHIAbwBqAGUAYwB0AHMALAAgAHQAbwAgAHMAdQBwAHAAbwByAHQAIAB0AGgAZQAgAGYAbwBuAHQAIABjAHIAZQBhAHQAaQBvAG4AIABlAGYAZgBvAHIAdABzACAAbwBmACAAYQBjAGEAZABlAG0AaQBjACAAYQBuAGQAIABsAGkAbgBnAHUAaQBzAHQAaQBjACAAYwBvAG0AbQB1AG4AaQB0AGkAZQBzACwAIABhAG4AZAAgAHQAbwAgAHAAcgBvAHYAaQBkAGUAIABhACAAZgByAGUAZQAgAGEAbgBkACAAbwBwAGUAbgAgAGYAcgBhAG0AZQB3AG8AcgBrACAAaQBuACAAdwBoAGkAYwBoACAAZgBvAG4AdABzACAAbQBhAHkAIABiAGUAIABzAGgAYQByAGUAZAAgAGEAbgBkACAAaQBtAHAAcgBvAHYAZQBkACAAaQBuACAAcABhAHIAdABuAGUAcgBzAGgAaQBwACAAdwBpAHQAaAAgAG8AdABoAGUAcgBzAC4ADQAKAA0ACgBUAGgAZQAgAE8ARgBMACAAYQBsAGwAbwB3AHMAIAB0AGgAZQAgAGwAaQBjAGUAbgBzAGUAZAAgAGYAbwBuAHQAcwAgAHQAbwAgAGIAZQAgAHUAcwBlAGQALAAgAHMAdAB1AGQAaQBlAGQALAAgAG0AbwBkAGkAZgBpAGUAZAAgAGEAbgBkACAAcgBlAGQAaQBzAHQAcgBpAGIAdQB0AGUAZAAgAGYAcgBlAGUAbAB5ACAAYQBzACAAbABvAG4AZwAgAGEAcwAgAHQAaABlAHkAIABhAHIAZQAgAG4AbwB0ACAAcwBvAGwAZAAgAGIAeQAgAHQAaABlAG0AcwBlAGwAdgBlAHMALgAgAFQAaABlACAAZgBvAG4AdABzACwAIABpAG4AYwBsAHUAZABpAG4AZwAgAGEAbgB5ACAAZABlAHIAaQB2AGEAdABpAHYAZQAgAHcAbwByAGsAcwAsACAAYwBhAG4AIABiAGUAIABiAHUAbgBkAGwAZQBkACwAIABlAG0AYgBlAGQAZABlAGQALAAgAHIAZQBkAGkAcwB0AHIAaQBiAHUAdABlAGQAIABhAG4AZAAvAG8AcgAgAHMAbwBsAGQAIAB3AGkAdABoACAAYQBuAHkAIABzAG8AZgB0AHcAYQByAGUAIABwAHIAbwB2AGkAZABlAGQAIAB0AGgAYQB0ACAAYQBuAHkAIAByAGUAcwBlAHIAdgBlAGQAIABuAGEAbQBlAHMAIABhAHIAZQAgAG4AbwB0ACAAdQBzAGUAZAAgAGIAeQAgAGQAZQByAGkAdgBhAHQAaQB2AGUAIAB3AG8AcgBrAHMALgAgAFQAaABlACAAZgBvAG4AdABzACAAYQBuAGQAIABkAGUAcgBpAHYAYQB0AGkAdgBlAHMALAAgAGgAbwB3AGUAdgBlAHIALAAgAGMAYQBuAG4AbwB0ACAAYgBlACAAcgBlAGwAZQBhAHMAZQBkACAAdQBuAGQAZQByACAAYQBuAHkAIABvAHQAaABlAHIAIAB0AHkAcABlACAAbwBmACAAbABpAGMAZQBuAHMAZQAuACAAVABoAGUAIAByAGUAcQB1AGkAcgBlAG0AZQBuAHQAIABmAG8AcgAgAGYAbwBuAHQAcwAgAHQAbwAgAHIAZQBtAGEAaQBuACAAdQBuAGQAZQByACAAdABoAGkAcwAgAGwAaQBjAGUAbgBzAGUAIABkAG8AZQBzACAAbgBvAHQAIABhAHAAcABsAHkAIAB0AG8AIABhAG4AeQAgAGQAbwBjAHUAbQBlAG4AdAAgAGMAcgBlAGEAdABlAGQAIAB1AHMAaQBuAGcAIAB0AGgAZQAgAGYAbwBuAHQAcwAgAG8AcgAgAHQAaABlAGkAcgAgAGQAZQByAGkAdgBhAHQAaQB2AGUAcwAuAA0ACgANAAoARABFAEYASQBOAEkAVABJAE8ATgBTAA0ACgAiAEYAbwBuAHQAIABTAG8AZgB0AHcAYQByAGUAIgAgAHIAZQBmAGUAcgBzACAAdABvACAAdABoAGUAIABzAGUAdAAgAG8AZgAgAGYAaQBsAGUAcwAgAHIAZQBsAGUAYQBzAGUAZAAgAGIAeQAgAHQAaABlACAAQwBvAHAAeQByAGkAZwBoAHQAIABIAG8AbABkAGUAcgAoAHMAKQAgAHUAbgBkAGUAcgAgAHQAaABpAHMAIABsAGkAYwBlAG4AcwBlACAAYQBuAGQAIABjAGwAZQBhAHIAbAB5ACAAbQBhAHIAawBlAGQAIABhAHMAIABzAHUAYwBoAC4AIABUAGgAaQBzACAAbQBhAHkAIABpAG4AYwBsAHUAZABlACAAcwBvAHUAcgBjAGUAIABmAGkAbABlAHMALAAgAGIAdQBpAGwAZAAgAHMAYwByAGkAcAB0AHMAIABhAG4AZAAgAGQAbwBjAHUAbQBlAG4AdABhAHQAaQBvAG4ALgANAAoADQAKACIAUgBlAHMAZQByAHYAZQBkACAARgBvAG4AdAAgAE4AYQBtAGUAIgAgAHIAZQBmAGUAcgBzACAAdABvACAAYQBuAHkAIABuAGEAbQBlAHMAIABzAHAAZQBjAGkAZgBpAGUAZAAgAGEAcwAgAHMAdQBjAGgAIABhAGYAdABlAHIAIAB0AGgAZQAgAGMAbwBwAHkAcgBpAGcAaAB0ACAAcwB0AGEAdABlAG0AZQBuAHQAKABzACkALgANAAoADQAKACIATwByAGkAZwBpAG4AYQBsACAAVgBlAHIAcwBpAG8AbgAiACAAcgBlAGYAZQByAHMAIAB0AG8AIAB0AGgAZQAgAGMAbwBsAGwAZQBjAHQAaQBvAG4AIABvAGYAIABGAG8AbgB0ACAAUwBvAGYAdAB3AGEAcgBlACAAYwBvAG0AcABvAG4AZQBuAHQAcwAgAGEAcwAgAGQAaQBzAHQAcgBpAGIAdQB0AGUAZAAgAGIAeQAgAHQAaABlACAAQwBvAHAAeQByAGkAZwBoAHQAIABIAG8AbABkAGUAcgAoAHMAKQAuAA0ACgANAAoAIgBNAG8AZABpAGYAaQBlAGQAIABWAGUAcgBzAGkAbwBuACIAIAByAGUAZgBlAHIAcwAgAHQAbwAgAGEAbgB5ACAAZABlAHIAaQB2AGEAdABpAHYAZQAgAG0AYQBkAGUAIABiAHkAIABhAGQAZABpAG4AZwAgAHQAbwAsACAAZABlAGwAZQB0AGkAbgBnACwAIABvAHIAIABzAHUAYgBzAHQAaQB0AHUAdABpAG4AZwAgAC0ALQAgAGkAbgAgAHAAYQByAHQAIABvAHIAIABpAG4AIAB3AGgAbwBsAGUAIAAtAC0AIABhAG4AeQAgAG8AZgAgAHQAaABlACAAYwBvAG0AcABvAG4AZQBuAHQAcwAgAG8AZgAgAHQAaABlACAATwByAGkAZwBpAG4AYQBsACAAVgBlAHIAcwBpAG8AbgAsACAAYgB5ACAAYwBoAGEAbgBnAGkAbgBnACAAZgBvAHIAbQBhAHQAcwAgAG8AcgAgAGIAeQAgAHAAbwByAHQAaQBuAGcAIAB0AGgAZQAgAEYAbwBuAHQAIABTAG8AZgB0AHcAYQByAGUAIAB0AG8AIABhACAAbgBlAHcAIABlAG4AdgBpAHIAbwBuAG0AZQBuAHQALgANAAoADQAKACIAQQB1AHQAaABvAHIAIgAgAHIAZQBmAGUAcgBzACAAdABvACAAYQBuAHkAIABkAGUAcwBpAGcAbgBlAHIALAAgAGUAbgBnAGkAbgBlAGUAcgAsACAAcAByAG8AZwByAGEAbQBtAGUAcgAsACAAdABlAGMAaABuAGkAYwBhAGwAIAB3AHIAaQB0AGUAcgAgAG8AcgAgAG8AdABoAGUAcgAgAHAAZQByAHMAbwBuACAAdwBoAG8AIABjAG8AbgB0AHIAaQBiAHUAdABlAGQAIAB0AG8AIAB0AGgAZQAgAEYAbwBuAHQAIABTAG8AZgB0AHcAYQByAGUALgANAAoADQAKAFAARQBSAE0ASQBTAFMASQBPAE4AIAAmACAAQwBPAE4ARABJAFQASQBPAE4AUwANAAoAUABlAHIAbQBpAHMAcwBpAG8AbgAgAGkAcwAgAGgAZQByAGUAYgB5ACAAZwByAGEAbgB0AGUAZAAsACAAZgByAGUAZQAgAG8AZgAgAGMAaABhAHIAZwBlACwAIAB0AG8AIABhAG4AeQAgAHAAZQByAHMAbwBuACAAbwBiAHQAYQBpAG4AaQBuAGcAIABhACAAYwBvAHAAeQAgAG8AZgAgAHQAaABlACAARgBvAG4AdAAgAFMAbwBmAHQAdwBhAHIAZQAsACAAdABvACAAdQBzAGUALAAgAHMAdAB1AGQAeQAsACAAYwBvAHAAeQAsACAAbQBlAHIAZwBlACwAIABlAG0AYgBlAGQALAAgAG0AbwBkAGkAZgB5ACwAIAByAGUAZABpAHMAdAByAGkAYgB1AHQAZQAsACAAYQBuAGQAIABzAGUAbABsACAAbQBvAGQAaQBmAGkAZQBkACAAYQBuAGQAIAB1AG4AbQBvAGQAaQBmAGkAZQBkACAAYwBvAHAAaQBlAHMAIABvAGYAIAB0AGgAZQAgAEYAbwBuAHQAIABTAG8AZgB0AHcAYQByAGUALAAgAHMAdQBiAGoAZQBjAHQAIAB0AG8AIAB0AGgAZQAgAGYAbwBsAGwAbwB3AGkAbgBnACAAYwBvAG4AZABpAHQAaQBvAG4AcwA6AA0ACgANAAoAMQApACAATgBlAGkAdABoAGUAcgAgAHQAaABlACAARgBvAG4AdAAgAFMAbwBmAHQAdwBhAHIAZQAgAG4AbwByACAAYQBuAHkAIABvAGYAIABpAHQAcwAgAGkAbgBkAGkAdgBpAGQAdQBhAGwAIABjAG8AbQBwAG8AbgBlAG4AdABzACwAIABpAG4AIABPAHIAaQBnAGkAbgBhAGwAIABvAHIAIABNAG8AZABpAGYAaQBlAGQAIABWAGUAcgBzAGkAbwBuAHMALAAgAG0AYQB5ACAAYgBlACAAcwBvAGwAZAAgAGIAeQAgAGkAdABzAGUAbABmAC4ADQAKAA0ACgAyACkAIABPAHIAaQBnAGkAbgBhAGwAIABvAHIAIABNAG8AZABpAGYAaQBlAGQAIABWAGUAcgBzAGkAbwBuAHMAIABvAGYAIAB0AGgAZQAgAEYAbwBuAHQAIABTAG8AZgB0AHcAYQByAGUAIABtAGEAeQAgAGIAZQAgAGIAdQBuAGQAbABlAGQALAAgAHIAZQBkAGkAcwB0AHIAaQBiAHUAdABlAGQAIABhAG4AZAAvAG8AcgAgAHMAbwBsAGQAIAB3AGkAdABoACAAYQBuAHkAIABzAG8AZgB0AHcAYQByAGUALAAgAHAAcgBvAHYAaQBkAGUAZAAgAHQAaABhAHQAIABlAGEAYwBoACAAYwBvAHAAeQAgAGMAbwBuAHQAYQBpAG4AcwAgAHQAaABlACAAYQBiAG8AdgBlACAAYwBvAHAAeQByAGkAZwBoAHQAIABuAG8AdABpAGMAZQAgAGEAbgBkACAAdABoAGkAcwAgAGwAaQBjAGUAbgBzAGUALgAgAFQAaABlAHMAZQAgAGMAYQBuACAAYgBlACAAaQBuAGMAbAB1AGQAZQBkACAAZQBpAHQAaABlAHIAIABhAHMAIABzAHQAYQBuAGQALQBhAGwAbwBuAGUAIAB0AGUAeAB0ACAAZgBpAGwAZQBzACwAIABoAHUAbQBhAG4ALQByAGUAYQBkAGEAYgBsAGUAIABoAGUAYQBkAGUAcgBzACAAbwByACAAaQBuACAAdABoAGUAIABhAHAAcAByAG8AcAByAGkAYQB0AGUAIABtAGEAYwBoAGkAbgBlAC0AcgBlAGEAZABhAGIAbABlACAAbQBlAHQAYQBkAGEAdABhACAAZgBpAGUAbABkAHMAIAB3AGkAdABoAGkAbgAgAHQAZQB4AHQAIABvAHIAIABiAGkAbgBhAHIAeQAgAGYAaQBsAGUAcwAgAGEAcwAgAGwAbwBuAGcAIABhAHMAIAB0AGgAbwBzAGUAIABmAGkAZQBsAGQAcwAgAGMAYQBuACAAYgBlACAAZQBhAHMAaQBsAHkAIAB2AGkAZQB3AGUAZAAgAGIAeQAgAHQAaABlACAAdQBzAGUAcgAuAA0ACgANAAoAMwApACAATgBvACAATQBvAGQAaQBmAGkAZQBkACAAVgBlAHIAcwBpAG8AbgAgAG8AZgAgAHQAaABlACAARgBvAG4AdAAgAFMAbwBmAHQAdwBhAHIAZQAgAG0AYQB5ACAAdQBzAGUAIAB0AGgAZQAgAFIAZQBzAGUAcgB2AGUAZAAgAEYAbwBuAHQAIABOAGEAbQBlACgAcwApACAAdQBuAGwAZQBzAHMAIABlAHgAcABsAGkAYwBpAHQAIAB3AHIAaQB0AHQAZQBuACAAcABlAHIAbQBpAHMAcwBpAG8AbgAgAGkAcwAgAGcAcgBhAG4AdABlAGQAIABiAHkAIAB0AGgAZQAgAGMAbwByAHIAZQBzAHAAbwBuAGQAaQBuAGcAIABDAG8AcAB5AHIAaQBnAGgAdAAgAEgAbwBsAGQAZQByAC4AIABUAGgAaQBzACAAcgBlAHMAdAByAGkAYwB0AGkAbwBuACAAbwBuAGwAeQAgAGEAcABwAGwAaQBlAHMAIAB0AG8AIAB0AGgAZQAgAHAAcgBpAG0AYQByAHkAIABmAG8AbgB0ACAAbgBhAG0AZQAgAGEAcwAgAHAAcgBlAHMAZQBuAHQAZQBkACAAdABvACAAdABoAGUAIAB1AHMAZQByAHMALgANAAoADQAKADQAKQAgAFQAaABlACAAbgBhAG0AZQAoAHMAKQAgAG8AZgAgAHQAaABlACAAQwBvAHAAeQByAGkAZwBoAHQAIABIAG8AbABkAGUAcgAoAHMAKQAgAG8AcgAgAHQAaABlACAAQQB1AHQAaABvAHIAKABzACkAIABvAGYAIAB0AGgAZQAgAEYAbwBuAHQAIABTAG8AZgB0AHcAYQByAGUAIABzAGgAYQBsAGwAIABuAG8AdAAgAGIAZQAgAHUAcwBlAGQAIAB0AG8AIABwAHIAbwBtAG8AdABlACwAIABlAG4AZABvAHIAcwBlACAAbwByACAAYQBkAHYAZQByAHQAaQBzAGUAIABhAG4AeQAgAE0AbwBkAGkAZgBpAGUAZAAgAFYAZQByAHMAaQBvAG4ALAAgAGUAeABjAGUAcAB0ACAAdABvACAAYQBjAGsAbgBvAHcAbABlAGQAZwBlACAAdABoAGUAIABjAG8AbgB0AHIAaQBiAHUAdABpAG8AbgAoAHMAKQAgAG8AZgAgAHQAaABlACAAQwBvAHAAeQByAGkAZwBoAHQAIABIAG8AbABkAGUAcgAoAHMAKQAgAGEAbgBkACAAdABoAGUAIABBAHUAdABoAG8AcgAoAHMAKQAgAG8AcgAgAHcAaQB0AGgAIAB0AGgAZQBpAHIAIABlAHgAcABsAGkAYwBpAHQAIAB3AHIAaQB0AHQAZQBuACAAcABlAHIAbQBpAHMAcwBpAG8AbgAuAA0ACgANAAoANQApACAAVABoAGUAIABGAG8AbgB0ACAAUwBvAGYAdAB3AGEAcgBlACwAIABtAG8AZABpAGYAaQBlAGQAIABvAHIAIAB1AG4AbQBvAGQAaQBmAGkAZQBkACwAIABpAG4AIABwAGEAcgB0ACAAbwByACAAaQBuACAAdwBoAG8AbABlACwAIABtAHUAcwB0ACAAYgBlACAAZABpAHMAdAByAGkAYgB1AHQAZQBkACAAZQBuAHQAaQByAGUAbAB5ACAAdQBuAGQAZQByACAAdABoAGkAcwAgAGwAaQBjAGUAbgBzAGUALAAgAGEAbgBkACAAbQB1AHMAdAAgAG4AbwB0ACAAYgBlACAAZABpAHMAdAByAGkAYgB1AHQAZQBkACAAdQBuAGQAZQByACAAYQBuAHkAIABvAHQAaABlAHIAIABsAGkAYwBlAG4AcwBlAC4AIABUAGgAZQAgAHIAZQBxAHUAaQByAGUAbQBlAG4AdAAgAGYAbwByACAAZgBvAG4AdABzACAAdABvACAAcgBlAG0AYQBpAG4AIAB1AG4AZABlAHIAIAB0AGgAaQBzACAAbABpAGMAZQBuAHMAZQAgAGQAbwBlAHMAIABuAG8AdAAgAGEAcABwAGwAeQAgAHQAbwAgAGEAbgB5ACAAZABvAGMAdQBtAGUAbgB0ACAAYwByAGUAYQB0AGUAZAAgAHUAcwBpAG4AZwAgAHQAaABlACAARgBvAG4AdAAgAFMAbwBmAHQAdwBhAHIAZQAuAA0ACgANAAoAVABFAFIATQBJAE4AQQBUAEkATwBOAA0ACgBUAGgAaQBzACAAbABpAGMAZQBuAHMAZQAgAGIAZQBjAG8AbQBlAHMAIABuAHUAbABsACAAYQBuAGQAIAB2AG8AaQBkACAAaQBmACAAYQBuAHkAIABvAGYAIAB0AGgAZQAgAGEAYgBvAHYAZQAgAGMAbwBuAGQAaQB0AGkAbwBuAHMAIABhAHIAZQAgAG4AbwB0ACAAbQBlAHQALgANAAoADQAKAEQASQBTAEMATABBAEkATQBFAFIADQAKAFQASABFACAARgBPAE4AVAAgAFMATwBGAFQAVwBBAFIARQAgAEkAUwAgAFAAUgBPAFYASQBEAEUARAAgACIAQQBTACAASQBTACIALAAgAFcASQBUAEgATwBVAFQAIABXAEEAUgBSAEEATgBUAFkAIABPAEYAIABBAE4AWQAgAEsASQBOAEQALAAgAEUAWABQAFIARQBTAFMAIABPAFIAIABJAE0AUABMAEkARQBEACwAIABJAE4AQwBMAFUARABJAE4ARwAgAEIAVQBUACAATgBPAFQAIABMAEkATQBJAFQARQBEACAAVABPACAAQQBOAFkAIABXAEEAUgBSAEEATgBUAEkARQBTACAATwBGACAATQBFAFIAQwBIAEEATgBUAEEAQgBJAEwASQBUAFkALAAgAEYASQBUAE4ARQBTAFMAIABGAE8AUgAgAEEAIABQAEEAUgBUAEkAQwBVAEwAQQBSACAAUABVAFIAUABPAFMARQAgAEEATgBEACAATgBPAE4ASQBOAEYAUgBJAE4ARwBFAE0ARQBOAFQAIABPAEYAIABDAE8AUABZAFIASQBHAEgAVAAsACAAUABBAFQARQBOAFQALAAgAFQAUgBBAEQARQBNAEEAUgBLACwAIABPAFIAIABPAFQASABFAFIAIABSAEkARwBIAFQALgAgAEkATgAgAE4ATwAgAEUAVgBFAE4AVAAgAFMASABBAEwATAAgAFQASABFACAAQwBPAFAAWQBSAEkARwBIAFQAIABIAE8ATABEAEUAUgAgAEIARQAgAEwASQBBAEIATABFACAARgBPAFIAIABBAE4AWQAgAEMATABBAEkATQAsACAARABBAE0AQQBHAEUAUwAgAE8AUgAgAE8AVABIAEUAUgAgAEwASQBBAEIASQBMAEkAVABZACwAIABJAE4AQwBMAFUARABJAE4ARwAgAEEATgBZACAARwBFAE4ARQBSAEEATAAsACAAUwBQAEUAQwBJAEEATAAsACAASQBOAEQASQBSAEUAQwBUACwAIABJAE4AQwBJAEQARQBOAFQAQQBMACwAIABPAFIAIABDAE8ATgBTAEUAUQBVAEUATgBUAEkAQQBMACAARABBAE0AQQBHAEUAUwAsACAAVwBIAEUAVABIAEUAUgAgAEkATgAgAEEATgAgAEEAQwBUAEkATwBOACAATwBGACAAQwBPAE4AVABSAEEAQwBUACwAIABUAE8AUgBUACAATwBSACAATwBUAEgARQBSAFcASQBTAEUALAAgAEEAUgBJAFMASQBOAEcAIABGAFIATwBNACwAIABPAFUAVAAgAE8ARgAgAFQASABFACAAVQBTAEUAIABPAFIAIABJAE4AQQBCAEkATABJAFQAWQAgAFQATwAgAFUAUwBFACAAVABIAEUAIABGAE8ATgBUACAAUwBPAEYAVABXAEEAUgBFACAATwBSACAARgBSAE8ATQAgAE8AVABIAEUAUgAgAEQARQBBAEwASQBOAEcAUwAgAEkATgAgAFQASABFACAARgBPAE4AVAAgAFMATwBGAFQAVwBBAFIARQAuAAAAAgAAAAAAAP8GAGQAAAAAAAAAAAAAAAAAAAAAAAAAAABfAAMABAAFAAYABwAIAAkACgALAAwADQAOAA8AEAARABIAEwAUABUAFgAXABgAGQAaABsAHAAdAB4AHwAgACEAIgAjACQAJQAmACcAKAApACoAKwAsAC0ALgAvADAAMQAyADMANAA1ADYANwA4ADkAOgA7ADwAPQA+AD8AQABBAEIAQwBEAEUARgBHAEgASQBKAEsATABNAE4ATwBQAFEAUgBTAFQAVQBWAFcAWABZAFoAWwBcAF0AXgBfAGAAYQAAAAMACAACABAAAf//AAIAAAABAAAAAAABAAAADgAAAAAAAAAAAAIAAQAAAF4AAQABAAAACgBKAGQAAmN5cmwADmxhdG4AGAAEAAAAAP//AAAAEAACSVBBIAAaVklUIAAiAAD//wACAAEAAAAA//8AAQABAAD//wAAAAJrZXJuAA5tYXJrABQAAAABAAEAAAABAAAAAgAGAA4ABAAEAAEAEAACAAAAAQAsAAEADAAQAAAAIAAiAAIAAAABAAYAIQAyADYAQQBSAFYAAAAGAAEAjgAEAAAABgAWADAASgBkAHIAgAAGAA7/nAAhADYAQQA2ADIADQA2//IAUgAXAAYADv+cACEAWABBAFgAMgChADYAvQBSAE8ABgAO/nAAIf6TAEH+kwAy//kANgAOAFL/YQADAA7/nABSABcAVv/VAAMADv+cAFIANgBWAEwAAwAO/nAAUgAJAFYAGQABAAYAIQAyADYAQQBSAFYAAQAAAAoATgBoAAJjeXJsAA5sYXRuABoABAAAAAD//wABAAAAEAACSVBBIAAaVklUIAAiAAD//wACAAAAAQAA//8AAQAAAAD//wABAAAAAmFhbHQADnNtY3AAFAAAAAEAAAAAAAEAAAABAAQAAwAAAAEACAABABgAAwAMABAAFAABAEEAAQBSAAEAVgABAAMAIQAyADYAAA==", _t = jt;
let l = {
  None: "None",
  AcuteAccent: "AcuteAccent",
  Stropha: "Stropha",
  StrophaLiquescent: "StrophaLiquescent",
  BeginningAscLiquescent: "BeginningAscLiquescent",
  BeginningDesLiquescent: "BeginningDesLiquescent",
  CustosDescLong: "CustosDescLong",
  CustosDescShort: "CustosDescShort",
  CustosLong: "CustosLong",
  CustosShort: "CustosShort",
  // clefs and other markings
  DoClef: "DoClef",
  FaClef: "FaClef",
  Flat: "Flat",
  Mora: "Mora",
  Natural: "Natural",
  OriscusAsc: "OriscusAsc",
  OriscusDes: "OriscusDes",
  OriscusLiquescent: "OriscusLiquescent",
  PodatusLower: "PodatusLower",
  PodatusUpper: "PodatusUpper",
  Porrectus1: "Porrectus1",
  // 1 staff line difference,
  Porrectus2: "Porrectus2",
  // 2 lines difference, etc...
  Porrectus3: "Porrectus3",
  Porrectus4: "Porrectus4",
  PunctumCavum: "PunctumCavum",
  PunctumQuadratum: "PunctumQuadratum",
  PunctumQuadratumAscLiquescent: "PunctumQuadratumAscLiquescent",
  PunctumQuadratumDesLiquescent: "PunctumQuadratumDesLiquescent",
  PunctumInclinatum: "PunctumInclinatum",
  PunctumInclinatumLiquescent: "PunctumInclinatumLiquescent",
  Quilisma: "Quilisma",
  TerminatingAscLiquescent: "TerminatingAscLiquescent",
  TerminatingDesLiquescent: "TerminatingDesLiquescent",
  VerticalEpisemaAbove: "VerticalEpisemaAbove",
  VerticalEpisemaBelow: "VerticalEpisemaBelow",
  VirgaLong: "VirgaLong",
  VirgaShort: "VirgaShort",
  Virgula: "Virgula",
  UpperBrace: "UpperBrace"
};
var I = {
  // namespaces  
  ns: "http://www.w3.org/2000/svg",
  xmlns: "http://www.w3.org/2000/xmlns/",
  xlink: "http://www.w3.org/1999/xlink",
  // create the root level svg object
  svg: function(o, t) {
    var A = document.createElementNS(this.ns, "svg");
    A.setAttribute("xmlns", this.ns), A.setAttribute("version", "1.1"), A.setAttributeNS(this.xmlns, "xmlns:xlink", this.xlink), A.setAttribute("width", o), A.setAttribute("height", t);
    var e = document.createElementNS(this.ns, "defs");
    return A.appendChild(e), A.defs = e, A.clearNotations = function() {
      for (A.removeChild(e); A.hasChildNodes(); )
        A.removeChild(A.lastChild);
      A.appendChild(e);
    }, A;
  },
  rect: function(o, t) {
    var A = document.createElementNS(this.ns, "rect");
    return A.setAttribute("width", o), A.setAttribute("height", t), A;
  },
  line: function(o, t, A, e) {
    var s = document.createElementNS(this.ns, "line");
    return s.setAttribute("x1", o), s.setAttribute("y1", t), s.setAttribute("x2", A), s.setAttribute("y2", e), s;
  },
  g: function() {
    var o = document.createElementNS(this.ns, "g");
    return o;
  },
  text: function() {
    var o = document.createElementNS(this.ns, "text");
    return o;
  },
  tspan: function(o) {
    var t = document.createElementNS(this.ns, "tspan");
    return t.textContent = o, t;
  },
  // nodeRef should be the id of the object in defs (without the #)
  use: function(o) {
    var t = document.createElementNS(this.ns, "use");
    return t.setAttributeNS(this.xlink, "xlink:href", "#" + o), t;
  },
  createFragment: function(o, t, A) {
    A == null && (A = "");
    var e = "<" + o + " ";
    for (var s in t)
      t.hasOwnProperty(s) && (e += s + '="' + t[s] + '" ');
    return e += ">" + A + "</" + o + ">", e;
  },
  parseFragment: function(o) {
    var t = document.createElement("svg");
    if (o) {
      var A = this.g();
      t.innerHTML = "<svg>" + o.replace(/\n/, "").replace(/<(\w+)([^<]+?)\/>/g, "<$1$2></$1>") + "</svg>";
      for (var e = 0, s = t.firstChild.childNodes.length; e < s; e++)
        A.appendChild(t.firstChild.firstChild);
      return A;
    }
  },
  translate: function(o, t, A) {
    return o.setAttribute("transform", "translate(" + t + "," + A + ")"), o;
  },
  scale: function(o, t, A) {
    return o.setAttribute("transform", "scale(" + t + "," + A + ")"), o;
  }
}, J = {
  // shapes
  Svg: 0,
  Canvas: 1
};
class $t {
  constructor(t = J.Svg) {
    this.textMeasuringStrategy = t, this.defs = {}, this.lyricTextSize = 16, this.lyricTextFont = "'Palatino Linotype', 'Book Antiqua', Palatino, serif", this.lyricTextColor = "#000", this.dropCapTextSize = 64, this.dropCapTextFont = this.lyricTextFont, this.dropCapTextColor = this.lyricTextColor, this.annotationTextSize = 13, this.annotationTextFont = this.lyricTextFont, this.annotationTextColor = this.lyricTextColor, this.glyphPunctumWidth = it.PunctumQuadratum.bounds.width, this.glyphPunctumHeight = it.PunctumQuadratum.bounds.height, this.glyphScaling = 1 / 16, this.staffInterval = this.glyphPunctumWidth * this.glyphScaling, this.staffLineWeight = Math.round(this.glyphPunctumWidth * this.glyphScaling / 8), this.neumeLineWeight = this.staffLineWeight, this.dividerLineWeight = this.neumeLineWeight, this.episemaLineWeight = this.neumeLineWeight, this.activeClef = null, this.neumeLineColor = "#000", this.staffLineColor = "#000", this.dividerLineColor = "#000", this.defaultLanguage = new Kt(), this.canvas = document.createElement("canvas"), this.canvasCtxt = this.canvas.getContext("2d");
    var A = window.devicePixelRatio || 1, e = this.canvasCtxt.webkitBackingStorePixelRatio || this.canvasCtxt.mozBackingStorePixelRatio || this.canvasCtxt.msBackingStorePixelRatio || this.canvasCtxt.oBackingStorePixelRatio || this.canvasCtxt.backingStorePixelRatio || 1;
    this.pixelRatio = A / e, this.canvasCtxt.setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0), t === J.Svg && (this.svgTextMeasurer = I.svg(1, 1), this.svgTextMeasurer.setAttribute("id", "TextMeasurer"), document.querySelector("body").appendChild(this.svgTextMeasurer));
    var s = new Jt(this, "-", S.SingleSyllable);
    this.hyphenWidth = s.bounds.width, this.minLyricWordSpacing = this.hyphenWidth, this.intraNeumeSpacing = this.staffInterval / 2, this.syllableConnector = "-", this.drawGuides = !1, this.drawDebuggingBounds = !0, this.activeNotations = null, this.currNotationIndex = -1, this.condensingTolerance = 0.9, this.autoColor = !0, this.insertFontsInDoc();
  }
  calculateHeightFromStaffPosition(t) {
    return -t * this.staffInterval;
  }
  insertFontsInDoc() {
    var t = document.getElementById("exsurge-fonts");
    t === null && (t = document.createElement("style"), t.id = "exsurge-fonts", t.appendChild(document.createTextNode("@font-face{font-family: 'Exsurge Characters';font-weight: normal;font-style: normal;src: url(" + _t + ") format('opentype');}")), document.head.appendChild(t));
  }
  // returns the next neume starting at this.currNotationIndex, or null
  // if there isn't a neume after this one...
  findNextNeume() {
    if (typeof this.currNotationIndex > "u")
      throw "findNextNeume() called without a valid currNotationIndex set";
    for (var t = this.currNotationIndex + 1; t < this.notations.length; t++) {
      var A = this.notations[t];
      if (A.isNeume)
        return A;
    }
    return null;
  }
  setCanvasSize(t, A) {
    this.canvas.width = t * this.pixelRatio, this.canvas.height = A * this.pixelRatio, this.canvas.style.width = t + "px", this.canvas.style.height = A + "px", this.canvasCtxt.setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0);
  }
}
class V {
  constructor() {
    this.bounds = new R(), this.origin = new nt(0, 0), this.selected = !1, this.highlighted = !1;
  }
  // draws the element on an html5 canvas
  draw(t) {
  }
  // returns svg code for the element, used for printing support
  createSvgFragment(t) {
    throw "ChantLayout Elements must implement createSvgFragment(ctxt)";
  }
}
class st extends V {
  constructor(t, A, e) {
    super();
    var s = t.calculateHeightFromStaffPosition(A), n = t.calculateHeightFromStaffPosition(e);
    if (s > n) {
      var a = s;
      s = n, n = a;
    }
    this.bounds.x = 0, this.bounds.y = s, this.bounds.width = t.dividerLineWeight, this.bounds.height = n - s, this.origin.x = this.bounds.width / 2, this.origin.y = s;
  }
  draw(t) {
    var A = t.canvasCtxt;
    A.lineWidth = this.bounds.width, A.strokeStyle = t.dividerLineColor, A.beginPath(), A.moveTo(this.bounds.x - this.origin.x, this.bounds.y), A.lineTo(this.bounds.x - this.origin.x, this.bounds.y + this.bounds.height), A.stroke();
  }
  createSvgFragment(t) {
    return I.createFragment("rect", {
      x: this.bounds.x,
      y: this.bounds.y,
      width: t.dividerLineWeight,
      height: this.bounds.height,
      fill: t.dividerLineColor,
      class: "dividerLine"
    });
  }
}
class pt extends V {
  constructor(t, A, e, s) {
    super();
    var n = A.staffPosition, a = e.staffPosition;
    if (n < a) {
      var r = n;
      n = a, a = r;
    }
    var c = t.calculateHeightFromStaffPosition(n), g = 0;
    s && (n - a === 1 && Math.abs(n) % 2 === 1 && a > -3 && a--, g += t.glyphPunctumHeight * t.glyphScaling / 2.2), g += t.calculateHeightFromStaffPosition(a), this.bounds.x = 0, this.bounds.y = c, this.bounds.width = t.neumeLineWeight, this.bounds.height = g - c, this.origin.x = 0, this.origin.y = 0;
  }
  draw(t) {
    var A = t.canvasCtxt;
    A.lineWidth = this.bounds.width, A.strokeStyle = t.neumeLineColor, A.beginPath();
    var e = this.bounds.x + this.bounds.width / 2;
    A.moveTo(e, this.bounds.y), A.lineTo(e, this.bounds.y + this.bounds.height), A.stroke();
  }
  createSvgFragment(t) {
    return I.createFragment("rect", {
      x: this.bounds.x,
      y: this.bounds.y,
      width: t.neumeLineWeight,
      height: this.bounds.height,
      fill: t.neumeLineColor,
      class: "neumeLine"
    });
  }
}
class tA extends V {
  constructor(t, A) {
    super();
    var e = A.staffPosition, s = t.calculateHeightFromStaffPosition(e), n;
    Math.abs(e % 2) === 0 ? n = s + t.staffInterval * 1.8 : n = s + t.staffInterval * 2.7, this.bounds.x = 0, this.bounds.y = s, this.bounds.width = t.neumeLineWeight, this.bounds.height = n - s, this.origin.x = 0, this.origin.y = 0;
  }
  draw(t) {
    var A = t.canvasCtxt;
    A.lineWidth = this.bounds.width, A.strokeStyle = t.neumeLineColor, A.beginPath(), A.moveTo(this.bounds.x, this.bounds.y), A.lineTo(this.bounds.x, this.bounds.y + this.bounds.height), A.stroke();
  }
  createSvgFragment(t) {
    return I.createFragment("rect", {
      x: this.bounds.x,
      y: this.bounds.y,
      width: t.neumeLineWeight,
      height: this.bounds.height,
      fill: t.neumeLineColor,
      class: "neumeLine"
    });
  }
}
class D extends V {
  constructor(t, A) {
    super(), this.glyph = null, this.setGlyph(t, A);
  }
  setGlyph(t, A) {
    if (this.glyphCode !== A) {
      if (typeof A > "u" || A === null || A === "" ? this.glyphCode = l.None : this.glyphCode = A, this.glyph = it[this.glyphCode], !t.defs.hasOwnProperty(this.glyphCode)) {
        var e = this.glyph.svgSrc;
        t.defs[this.glyphCode] = I.createFragment("g", {
          id: this.glyphCode,
          class: "glyph",
          transform: "scale(" + t.glyphScaling + ")"
        }, e);
      }
      this.align = this.glyph.align, this.origin.x = this.glyph.origin.x * t.glyphScaling, this.origin.y = this.glyph.origin.y * t.glyphScaling, this.bounds.x = 0, this.bounds.y = -this.origin.y, this.bounds.width = this.glyph.bounds.width * t.glyphScaling, this.bounds.height = this.glyph.bounds.height * t.glyphScaling;
    }
  }
  setStaffPosition(t, A) {
    this.bounds.y += t.calculateHeightFromStaffPosition(A);
  }
  draw(t) {
    var A = t.canvasCtxt, e = this.bounds.x + this.origin.x, s = this.bounds.y + this.origin.y;
    A.translate(e, s), A.scale(t.glyphScaling, t.glyphScaling);
    for (var n = 0; n < this.glyph.paths.length; n++) {
      var a = this.glyph.paths[n];
      A.fillStyle = t.neumeLineColor, A.fill(new Path2D(a.data));
    }
    A.scale(1 / t.glyphScaling, 1 / t.glyphScaling), A.translate(-e, -s);
  }
  createSvgFragment(t) {
    return I.createFragment("use", {
      "xlink:href": "#" + this.glyphCode,
      x: this.bounds.x + this.origin.x,
      y: this.bounds.y + this.origin.y
    });
  }
}
class AA extends V {
  constructor(t, A, e, s, n) {
    if (super(), A > e) {
      var a = A;
      A = e, e = a;
    }
    this.isAbove = n, this.braceHeight = t.staffInterval / 2, this.bounds = new R(A, s, e - A, this.braceHeight), this.origin.x = 0, this.origin.y = 0;
  }
  createSvgFragment(t) {
    var A = I.createFragment("path", {
      d: this.generatePathString(),
      stroke: t.neumeLineColor,
      "stroke-width": t.staffLineWeight + "px",
      fill: "none",
      class: "brace"
    });
    return this.acuteAccent ? (A += this.acuteAccent.createSvgFragment(t), I.createFragment("g", {
      class: "accentedBrace"
    }, A)) : A;
  }
  // returns svg path d string
  generatePathString() {
    var t = this.bounds.x, A = this.bounds.right(), e = this.bounds.width, s, n, a;
    this.isAbove ? (s = this.bounds.bottom(), n = e / 6, a = -e / 6) : (s = this.bounds.y, n = e / 6, a = e / 6);
    var r = t + n, c = s + a, g = A - n, h = 2;
    return "M " + t.toFixed(h) + " " + s.toFixed(h) + " C " + r.toFixed(h) + " " + c.toFixed(h) + " " + g.toFixed(h) + " " + c.toFixed(h) + " " + A.toFixed(h) + " " + s.toFixed(h);
  }
}
class eA extends V {
  constructor(t, A, e, s, n = !0, a = !1) {
    if (super(), A > e) {
      var r = A;
      A = e, e = r;
    }
    this.isAbove = n, this.braceHeight = t.staffInterval / 2, n && (s -= this.braceHeight);
    var c = new R(A, s, e - A, this.braceHeight);
    a && n && (this.acuteAccent = new D(t, l.AcuteAccent), this.acuteAccent.bounds.x += c.x + (e - A) / 2, this.acuteAccent.bounds.y += c.y - t.staffInterval / 4, c.union(this.acuteAccent.bounds)), this.bounds = c, this.origin.x = 0, this.origin.y = 0;
  }
  createSvgFragment(t) {
    var A = I.createFragment("path", {
      d: this.generatePathString(),
      stroke: t.neumeLineColor,
      "stroke-width": t.staffLineWeight + "px",
      fill: "none",
      class: "brace"
    });
    return this.acuteAccent ? (A += this.acuteAccent.createSvgFragment(t), I.createFragment("g", {
      class: "accentedBrace"
    }, A)) : A;
  }
  // code below inspired by: https://gist.github.com/alexhornbake
  // optimized for braces that are only drawn horizontally.
  // returns svg path d string
  generatePathString() {
    var t = 0.6, A = this.bounds.x, e = this.bounds.right(), s = this.bounds.width, n, a;
    this.isAbove ? (n = this.bounds.bottom(), a = -this.braceHeight) : (n = this.bounds.y, a = this.braceHeight);
    var r = n + t * a, c = A + 0.25 * s, g = n + (1 - t) * a, h = A + 0.5 * s, f = n + a, d = n + t * a, B = A + 0.75 * s, v = n + (1 - t) * a, Q = 2;
    return "M " + A.toFixed(Q) + " " + n.toFixed(Q) + " Q " + A.toFixed(Q) + " " + r.toFixed(Q) + " " + c.toFixed(Q) + " " + g.toFixed(Q) + " T " + h.toFixed(Q) + " " + f.toFixed(Q) + " M " + e.toFixed(Q) + " " + n.toFixed(Q) + " Q " + e.toFixed(Q) + " " + d.toFixed(Q) + " " + B.toFixed(Q) + " " + v.toFixed(Q) + " T " + h.toFixed(Q) + " " + f.toFixed(Q);
  }
}
var Gt = function(o, t) {
  (typeof t > "u" || t === null) && (t = ""), this.text = o, this.properties = t;
}, iA = "*", sA = "_", nA = "^", aA = "%";
function gt(o, t, A) {
  this.symbol = o, this.startIndex = t, this.properties = A;
}
gt.createStackFrame = function(o, t) {
  var A = "";
  switch (o) {
    case iA:
      A = "font-weight:bold;";
      break;
    case sA:
      A = "font-style:italic;";
      break;
    case nA:
      A = "fill:#f00;";
      break;
    case aA:
      A = "font-variant:small-caps;font-feature-settings:'smcp';-webkit-font-feature-settings:'smcp';";
      break;
  }
  return new gt(o, t, A);
};
var rA = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;"
};
class at extends V {
  constructor(t, A, e, s, n) {
    super(), this.bounds.x = 0, this.bounds.y = 0, this.bounds.width = 0, this.bounds.height = 0, this.origin.x = 0, this.origin.y = 0, this.fontFamily = e, this.fontSize = s, this.textAnchor = n, this.dominantBaseline = "baseline", this.generateSpansFromText(t, A), this.recalculateMetrics(t);
  }
  generateSpansFromText(t, A) {
    if (this.text = "", this.spans = [], A === "*" || A === "†") {
      this.spans.push(new Gt(A));
      return;
    }
    for (var e = [], s = 0, n = (f, d) => f.Symbol === d, a = this, r = function(f, d) {
      if (f !== "") {
        a.text += f;
        for (var B = "", v = 0; v < e.length; v++)
          B += e[v].properties;
        d && (B = B + d), a.spans.push(new Gt(f, B));
      }
    }, c = /(\*|_|\^|%|[ARVarv]\/\.)/g, g = null; g = c.exec(A); ) {
      var h = g[0];
      if (h === "A/." || h === "R/." || h === "V/." || h === "a/." || h === "r/." || h === "v/.")
        r(A[g.index] + ".", "font-family:'Exsurge Characters';fill:#f00;");
      else if (e.length === 0)
        r(A.substring(s, g.index)), e.push(gt.createStackFrame(h, g.index));
      else if (e[e.length - 1].symbol === h)
        r(A.substring(s, g.index)), e.pop();
      else if (e.filter(n).length > 0) {
        s = e[e.length - 1].startIndex, e.pop();
        continue;
      } else
        r(A.substring(s, g.index)), e.push(gt.createStackFrame(h, g.index));
      s = g.index + h.length;
    }
    s < A.length && r(A.substring(s, A.length)), this.spans.length === 0 && r(A);
  }
  measureSubstring(t, A) {
    if (A === 0) return 0;
    A || (A = 1 / 0);
    for (var e = t.canvasCtxt, s = this.fontSize + "px " + this.fontFamily, n = 0, a = 0, r = 0; r < this.spans.length; r++) {
      var c = "", g = this.spans[r], h = g.text.slice(0, A - a);
      g.properties.indexOf("font-style:italic;") >= 0 && (c += "italic "), g.properties.indexOf("font-variant:small-caps;") >= 0 && (c += "small-caps "), g.properties.indexOf("font-weight:bold;") >= 0 && (c += "bold "), c += s, e.font = c;
      var f = e.measureText(h, this.bounds.x, this.bounds.y);
      if (n += f.width, a += h.length, a === A) break;
    }
    return n;
  }
  recalculateMetrics(t) {
    if (this.bounds.x = 0, this.bounds.y = 0, this.bounds.x = 0, this.bounds.y = 0, this.origin.x = 0, t.textMeasuringStrategy === J.Svg) {
      for (var A = '<svg xmlns="http://www.w3.org/2000/svg">' + this.createSvgFragment(t) + "</svg>", e = new DOMParser().parseFromString(A, "application/xml"); t.svgTextMeasurer.firstChild; )
        t.svgTextMeasurer.firstChild.remove();
      t.svgTextMeasurer.appendChild(t.svgTextMeasurer.ownerDocument.importNode(e.documentElement, !0).firstChild);
      var s = t.svgTextMeasurer.firstChild.getBBox();
      this.bounds.width = s.width, this.bounds.height = s.height, this.origin.y = -s.y;
    } else t.textMeasuringStrategy === J.Canvas && (this.bounds.width = this.measureSubstring(t), this.bounds.height = this.fontSize * 1.2, this.origin.y = this.fontSize);
  }
  getCssClasses() {
    return "";
  }
  getExtraStyleProperties(t) {
    return "";
  }
  static escapeForTspan(t) {
    return String(t).replace(/[&<>]/g, function(A) {
      return rA[A];
    });
  }
  draw(t) {
    var A = t.canvasCtxt;
    this.textAnchor === "middle" ? A.textAlign = "center" : A.textAlign = "start", A.font = this.fontSize + "px " + this.fontFamily;
    for (var e = 0; e < this.spans.length; e++)
      A.fillText(this.spans[e].text, this.bounds.x, this.bounds.y);
  }
  createSvgFragment(t) {
    for (var A = "", e = 0; e < this.spans.length; e++) {
      var s = {};
      this.spans[e].properties && (s.style = this.spans[e].properties), A += I.createFragment("tspan", s, at.escapeForTspan(this.spans[e].text));
    }
    var n = "font-family:" + this.fontFamily + ";font-size:" + this.fontSize + "px;font-kerning:normal;" + this.getExtraStyleProperties(t);
    return I.createFragment("text", {
      x: this.bounds.x,
      y: this.bounds.y,
      class: this.getCssClasses().trim(),
      "text-anchor": this.textAnchor,
      "dominant-baseline": this.dominantBaseline,
      style: n
    }, A);
  }
}
var S = {
  SingleSyllable: 0,
  BeginningSyllable: 1,
  MiddleSyllable: 2,
  EndingSyllable: 3,
  Directive: 4
  // for asterisks, "ij." elements, or other performance notes.
};
class Jt extends at {
  constructor(t, A, e) {
    super(t, A, t.lyricTextFont, t.lyricTextSize, "start"), this.originalText = A, typeof e > "u" || e === null || e === "" ? this.lyricType = S.SingleSyllable : this.lyricType = e, this.centerStartIndex = -1, this.centerLength = A.length, this.needsConnector = !1, this.language = null;
  }
  allowsConnector() {
    return this.lyricType === S.BeginningSyllable || this.lyricType === S.MiddleSyllable;
  }
  setNeedsConnector(t) {
    t === !0 ? (this.needsConnector = !0, this.bounds.width = this.widthWithConnector, this.spans.length > 0 && (this.spans[this.spans.length - 1].text = this.lastSpanTextWithConnector)) : (this.needsConnector = !1, this.bounds.width = this.widthWithoutConnector, this.spans.length > 0 && (this.spans[this.spans.length - 1].text = this.lastSpanText));
  }
  generateSpansFromText(t, A) {
    super.generateSpansFromText(t, A), this.spans.length > 0 ? (this.lastSpanText = this.spans[this.spans.length - 1].text, this.lastSpanTextWithConnector = this.lastSpanText + t.syllableConnector) : (this.lastSpanText = "", this.lastSpanTextWithConnector = "");
  }
  recalculateMetrics(t) {
    super.recalculateMetrics(t), this.widthWithoutConnector = this.bounds.width, this.textWithConnector = this.text + t.syllableConnector, this.widthWithConnector = this.bounds.width + t.hyphenWidth;
    var A = this.language || t.defaultLanguage, e = this.widthWithoutConnector / 2, s, n;
    if (this.centerStartIndex >= 0 && (this.centerStartIndex >= this.text.length || this.centerLength < 0 || this.centerStartIndex + this.centerLength > this.text.length) && (this.centerStartIndex = -1), this.text.length !== 0) {
      if (this.centerStartIndex >= 0)
        t.textMeasuringStrategy === J.Svg ? (s = t.svgTextMeasurer.firstChild.getSubStringLength(0, this.centerStartIndex), n = t.svgTextMeasurer.firstChild.getSubStringLength(0, this.centerStartIndex + this.centerLength)) : t.textMeasuringStrategy === J.Canvas && (s = this.measureSubstring(t, this.centerStartIndex), n = this.measureSubstring(t, this.centerStartIndex + this.centerLength)), e = s + (n - s) / 2;
      else if (this.lyricType !== S.Directive) {
        var a = A.findVowelSegment(this.text, 0);
        a.found === !0 && (t.textMeasuringStrategy === J.Svg ? (s = t.svgTextMeasurer.firstChild.getSubStringLength(0, a.startIndex), n = t.svgTextMeasurer.firstChild.getSubStringLength(0, a.startIndex + a.length)) : t.textMeasuringStrategy === J.Canvas && (s = this.measureSubstring(t, a.startIndex), n = this.measureSubstring(t, a.startIndex + a.length)), e = s + (n - s) / 2);
      }
    }
    this.bounds.x = -e, this.bounds.y = 0, this.origin.x = e, this.bounds.width = this.widthWithoutConnector, this.bounds.height = t.lyricTextSize;
  }
  generateDropCap(t) {
    var A = new oA(t, this.originalText.substring(0, 1));
    return this.originalText.length === 1 ? (this.generateSpansFromText(t, t.syllableConnector), this.centerStartIndex = -1, this.lyricType = S.SingleSyllable) : (this.generateSpansFromText(t, this.originalText.substring(1)), this.centerStartIndex--), A;
  }
  getCssClasses() {
    var t = "lyric ";
    return this.lyricType === S.Directive && (t += "directive "), t + super.getCssClasses();
  }
  getExtraStyleProperties(t) {
    var A = super.getExtraStyleProperties();
    return this.lyricType === S.Directive && t.autoColor === !0 && (A += "fill:#f00;"), A;
  }
  createSvgFragment(t) {
    return this.spans.length > 0 && (this.needsConnector ? this.spans[this.spans.length - 1].text = this.lastSpanTextWithConnector : this.spans[this.spans.length - 1].text = this.lastSpanText), super.createSvgFragment(t);
  }
}
class oA extends at {
  /**
   * @param {String} text
   */
  constructor(t, A) {
    super(t, A, t.dropCapTextFont, t.dropCapTextSize, "middle"), this.padding = t.staffInterval * 2;
  }
  getCssClasses() {
    return "dropCap " + super.getCssClasses();
  }
}
class qt extends at {
  /**
   * @param {String} text
   */
  constructor(t, A) {
    super(t, A, t.annotationTextFont, t.annotationTextSize, "middle"), this.padding = t.staffInterval, this.dominantBaseline = "hanging";
  }
  getCssClasses() {
    return "annotation " + super.getCssClasses();
  }
}
class K extends V {
  constructor() {
    super(), this.leadingSpace = 0, this.trailingSpace = -1, this.keepWithNext = !1, this.needsLayout = !0, this.lyrics = [], this.score = null, this.line = null, this.visualizers = [];
  }
  hasLyrics() {
    return this.lyrics.length !== 0;
  }
  getLyricLeft(t) {
    return this.bounds.x + this.lyrics[t].bounds.x;
  }
  getAllLyricsLeft() {
    if (this.lyrics.length === 0)
      return this.bounds.right();
    for (var t = Number.MAX_VALUE, A = 0; A < this.lyrics.length; A++)
      this.lyrics[A] && (t = Math.min(t, this.lyrics[A].bounds.x));
    return this.bounds.x + t;
  }
  getLyricRight(t) {
    return this.bounds.x + this.lyrics[t].bounds.x + this.lyrics[t].bounds.width;
  }
  getAllLyricsRight() {
    if (this.lyrics.length === 0)
      return this.bounds.x;
    for (var t = Number.MIN_VALUE, A = 0; A < this.lyrics.length; A++)
      this.lyrics[A] && (t = Math.max(t, this.lyrics[A].bounds.x + this.lyrics[A].bounds.width));
    return this.bounds.x + t;
  }
  // used by subclasses while building up the chant notations.
  addVisualizer(t) {
    this.bounds.isEmpty() ? this.bounds = t.bounds.clone() : this.bounds.union(t.bounds), this.visualizers.push(t);
  }
  // same as addVisualizer, except the element is unshifted to the front
  // of the visualizer array rather than the end. This way, some
  // visualizers can be placed behind the others...ledger lines for example.
  prependVisualizer(t) {
    this.bounds.isEmpty() ? this.bounds = t.bounds.clone() : this.bounds.union(t.bounds), this.visualizers.unshift(t);
  }
  // chant notation elements are given an opportunity to perform their layout via this function.
  // subclasses should call this function first in overrides of this function.
  // on completion, exsurge presumes that the bounds, the origin, and the fragment objects are
  // all valid and prepared for higher level layout.
  performLayout(t) {
    this.trailingSpace < 0 && (this.trailingSpace = t.intraNeumeSpacing * 4), this.visualizers = [], this.bounds = new R(1 / 0, 1 / 0, -1 / 0, -1 / 0);
    for (var A = 0; A < this.lyrics.length; A++)
      this.lyrics[A].recalculateMetrics(t);
  }
  // some subclasses have internal dependencies on other notations (for example,
  // a custos can depend on a later neume which it uses to set its height).
  // subclasses can override this function so that when the notations are 
  // altered, the subclass can correctly invalidate (and later restore) its own
  // depedencies
  resetDependencies() {
  }
  // a helper function for subclasses to call after they are done performing layout...
  finishLayout(t) {
    this.bounds.x = 0;
    for (var A = 0; A < this.lyrics.length; A++)
      this.lyrics[A].bounds.x = this.origin.x - this.lyrics[A].origin.x;
    this.needsLayout = !1;
  }
  draw(t) {
    var A = t.canvasCtxt;
    A.translate(this.bounds.x, 0);
    for (var e = 0; e < this.visualizers.length; e++)
      this.visualizers[e].draw(t);
    for (e = 0; e < this.lyrics.length; e++)
      this.lyrics[e].draw(t);
    A.translate(-this.bounds.x, 0);
  }
  createSvgFragment(t) {
    for (var A = "", e = 0; e < this.visualizers.length; e++)
      A += this.visualizers[e].createSvgFragment(t);
    for (e = 0; e < this.lyrics.length; e++)
      A += this.lyrics[e].createSvgFragment(t);
    return I.createFragment("g", {
      // this.constructor.name will not be the same after being mangled by UglifyJS
      class: "ChantNotationElement " + this.constructor.name,
      transform: "translate(" + this.bounds.x + ",0)"
    }, A);
  }
}
class O extends K {
  // if auto is true, then the custos will automatically try to determine it's height based on
  // subsequent notations
  constructor(t = !1) {
    super(), this.auto = t, this.staffPosition = 0;
  }
  performLayout(t) {
    if (super.performLayout(t), this.auto) {
      var A = t.findNextNeume();
      A && (this.staffPosition = t.activeClef.pitchToStaffPosition(A.notes[0].pitch));
    }
    var e = new D(t, O.getGlyphCode(this.staffPosition));
    e.setStaffPosition(t, this.staffPosition), this.addVisualizer(e), this.finishLayout(t);
  }
  // called when layout has changed and our dependencies are no longer good
  resetDependencies() {
    this.auto && (this.needsLayout = !0);
  }
  static getGlyphCode(t) {
    return t <= 2 ? Math.abs(t) % 2 === 1 ? l.CustosLong : l.CustosShort : Math.abs(t) % 2 === 1 ? l.CustosDescLong : l.CustosDescShort;
  }
}
class rt extends K {
  constructor() {
    super(), this.isDivider = !0, this.resetsAccidentals = !0;
  }
}
class hA extends rt {
  performLayout(t) {
    super.performLayout(t), this.addVisualizer(new st(t, 2, 4)), this.origin.x = this.bounds.width / 2, this.finishLayout(t);
  }
}
class lA extends rt {
  performLayout(t) {
    super.performLayout(t), this.addVisualizer(new st(t, -2, 2)), this.origin.x = this.bounds.width / 2, this.finishLayout(t);
  }
}
class uA extends rt {
  performLayout(t) {
    super.performLayout(t), this.addVisualizer(new st(t, -3, 3)), this.origin.x = this.bounds.width / 2, this.finishLayout(t);
  }
}
class gA extends rt {
  performLayout(t) {
    super.performLayout(t);
    var A = new st(t, -3, 3);
    A.bounds.x = 0, this.addVisualizer(A);
    var e = new st(t, -3, 3);
    e.bounds.x = t.intraNeumeSpacing * 2, this.addVisualizer(e), this.origin.x = this.bounds.width / 2, this.finishLayout(t);
  }
}
const x = {
  Flat: -1,
  Natural: 0,
  Sharp: 1
};
class vt extends K {
  constructor(t, A) {
    super(), this.isAccidental = !0, this.keepWithNext = !0, this.staffPosition = t, this.accidentalType = A;
  }
  performLayout(t) {
    super.performLayout(t), this.addVisualizer(this.createGlyphVisualizer(t)), this.finishLayout(t);
  }
  // creation of the glyph visualizer is refactored out or performLayout
  // so that clefs can use the same logic for their accidental glyph
  createGlyphVisualizer(t) {
    var A = l.Flat;
    switch (this.accidentalType) {
      case x.Natural:
        A = l.Natural;
        break;
      case x.Sharp:
        A = l.Sharp;
        break;
      default:
        A = l.Flat;
        break;
    }
    var e = new D(t, A);
    return e.setStaffPosition(t, this.staffPosition), e;
  }
  adjustStep(t) {
    switch (this.accidentalType) {
      case x.Flat:
        if (t === Step.Ti) return Step.Te;
        if (t === Step.Mi) return Step.Me;
        break;
      case x.Sharp:
        if (t === Step.Do) return Step.Du;
        if (t === Step.Fa) return Step.Fu;
        break;
      case x.Natural:
        if (t === Step.Te) return Step.Ti;
        if (t === Step.Me) return Step.Mi;
        if (t === Step.Du) return Step.Do;
        if (t === Step.Fu) return Step.Fa;
        break;
    }
    return t;
  }
  applyToPitch(t) {
    this.octave === t.octave && (t.step = this.adjustStep(t.step));
  }
}
class cA extends rt {
  constructor() {
    super(), this.resetsAccidentals = !1, this.staffPosition = 3;
  }
  performLayout(t) {
    super.performLayout(t);
    var A = new D(t, l.Virgula);
    A.setStaffPosition(t, this.staffPosition), this.addVisualizer(A), this.origin.x = this.bounds.width / 2, this.finishLayout(t);
  }
}
var u = {
  Default: 0,
  Above: 1,
  Below: 2
};
class fA extends D {
  constructor(t, A) {
    super(t, l.AcuteAccent), this.note = A, this.positionHint = u.Above;
  }
  performLayout(t) {
    this.bounds.x += this.bounds.width / 2, this.setStaffPosition(t, Math.max(this.note.staffPosition + 1, 4));
  }
}
var z = {
  Default: 0,
  Left: 1,
  Center: 2,
  Right: 3
};
class BA extends V {
  constructor(t) {
    super(), this.note = t, this.positionHint = u.Default, this.terminating = !1, this.alignment = z.Default;
  }
  performLayout(t) {
    var A = 0, e, s = t.staffInterval * 0.4;
    this.positionHint === u.Below ? (A = this.note.bounds.bottom() + s, e = Math.floor(A / t.staffInterval), Math.abs(e % 2) === 1 && (e = e + 1)) : (A = this.note.bounds.y - s, e = Math.ceil(A / t.staffInterval), Math.abs(e % 2) === 1 && (e = e - 1)), A = e * t.staffInterval;
    var n = this.note.glyphVisualizer.glyphCode, a;
    n === l.Porrectus1 || n === l.Porrectus2 || n === l.Porrectus3 || n === l.Porrectus4 ? a = t.staffInterval : a = this.note.bounds.width;
    var r = this.note.bounds.x;
    this.alignment === z.Left ? a *= 0.8 : this.alignment === z.Center ? (r += a * 0.2, a *= 0.6) : this.alignment === z.Right && (r += a * 0.2, a *= 0.8), this.bounds.x = r, this.bounds.y = A, this.bounds.width = a, this.bounds.height = t.episemaLineWeight, this.origin.x = 0, this.origin.y = 0;
  }
  createSvgFragment(t) {
    return I.createFragment("rect", {
      x: this.bounds.x,
      y: this.bounds.y,
      width: this.bounds.width,
      height: this.bounds.height,
      fill: t.neumeLineColor,
      class: "horizontalEpisema"
    });
  }
}
class dA extends D {
  constructor(t, A) {
    super(t, l.VerticalEpisemaAbove), this.note = A, this.positionHint = u.Default;
  }
  performLayout(t) {
    var A;
    this.positionHint === u.Above ? A = l.VerticalEpisemaAbove : A = l.VerticalEpisemaBelow;
    var e = this.note.staffPosition, s = this.note.bounds.width / 2, n = 0;
    switch (A) {
      case l.VerticalEpisemaAbove:
        e % 2 === 0 ? n -= t.staffInterval * 1.5 : n -= t.staffInterval * 0.9;
        break;
      case l.VerticalEpisemaBelow:
      default:
        e % 2 === 0 ? n += t.staffInterval * 1.5 : n += t.staffInterval * 0.8;
        break;
    }
    this.setGlyph(t, A), this.setStaffPosition(t, e), this.bounds.x = this.note.bounds.x + s - this.origin.x, this.bounds.y += n;
  }
}
class pA extends D {
  constructor(t, A) {
    super(t, l.Mora), this.note = A, this.positionHint = u.Default;
  }
  performLayout(t) {
    var A = this.note.staffPosition;
    this.setStaffPosition(t, A);
    var e = 0;
    this.positionHint === u.Above ? A % 2 === 0 ? e -= t.staffInterval + t.staffInterval * 0.75 : e -= t.staffInterval * 0.75 : this.positionHint === u.Below ? A % 2 === 0 ? e += t.staffInterval + t.staffInterval * 0.75 : e += t.staffInterval * 0.75 : Math.abs(A) % 2 === 1 && (e -= t.staffInterval * 0.75), this.bounds.x += this.note.bounds.right() + t.staffInterval / 4, this.bounds.y += e;
  }
}
var $ = {
  RoundBrace: 0,
  CurlyBrace: 1,
  AccentedCurlyBrace: 2
}, yt = {
  Left: 0,
  Right: 1
};
class It extends V {
  constructor(t, A, e, s) {
    super(), this.note = t, this.isAbove = A, this.shape = e, this.attachment = s;
  }
  getAttachmentX() {
    return this.attachment === yt.Left ? this.note.neume.bounds.x + this.note.bounds.x : this.note.neume.bounds.x + this.note.bounds.right();
  }
}
class vA extends V {
  constructor(t) {
    super(), this.score = t, this.notationsStartIndex = 0, this.numNotationsOnLine = 0, this.notationBounds = null, this.staffLeft = 0, this.staffRight = 0, this.startingClef = null, this.custos = null, this.justify = !0, this.ledgerLines = [], this.braces = [], this.nextLine = null, this.previousLine = null, this.lyricLineHeights = [], this.lyricLineBaselines = [], this.spaceAfterNotations = 0, this.spaceBetweenTextTracks = 0;
  }
  performLayout(t) {
    this.notationBounds = new R(
      this.staffLeft,
      -3.1 * t.staffInterval,
      this.staffRight - this.staffLeft,
      6.2 * t.staffInterval
    );
    var A, e = this.score.notations, s = this.notationsStartIndex + this.numNotationsOnLine, n = null;
    for (this.notationBounds.union(this.startingClef.bounds), this.lyricLineHeights = [], this.lyricLineBaselines = [], A = this.notationsStartIndex; A < s; A++)
      for (n = e[A], this.notationBounds.union(n.bounds), r = 0; r < n.lyrics.length; r++)
        this.lyricLineHeights.length < r + 1 && (this.lyricLineHeights.push(0), this.lyricLineBaselines.push(0)), this.lyricLineHeights[r] = Math.max(this.lyricLineHeights[r], n.lyrics[r].bounds.height), this.lyricLineBaselines[r] = Math.max(this.lyricLineBaselines[r], n.lyrics[r].origin.y);
    for (this.custos && this.notationBounds.union(this.custos.bounds), A = this.notationsStartIndex; A < s; A++) {
      n = e[A];
      for (var a = this.notationBounds.y + this.notationBounds.height, r = 0; r < n.lyrics.length; r++)
        n.lyrics[r].bounds.y = a + this.lyricLineBaselines[r], a += this.lyricLineHeights[r];
    }
    for (A = 0; A < this.braces.length; A++)
      this.notationBounds.union(this.braces[A].bounds);
    var c = this.notationBounds.height;
    for (A = 0; A < this.lyricLineHeights.length; A++)
      c += this.lyricLineHeights[A];
    if (this.notationsStartIndex === 0) {
      if (this.score.dropCap !== null) {
        var g;
        this.lyricLineHeights.length > 0 ? g = this.notationBounds.y + this.notationBounds.height + this.lyricLineBaselines[0] : g = this.notationBounds.y + this.notationBounds.height, this.score.dropCap.bounds.x = this.staffLeft / 2, this.score.dropCap.bounds.y = g;
      }
      this.score.annotation !== null && (this.score.annotation.bounds.x = this.staffLeft / 2, this.score.annotation.bounds.y = -t.staffInterval * 3);
    }
    this.notationBounds.height += t.lyricTextSize, this.bounds.x = 0, this.bounds.y = this.notationBounds.y, this.bounds.width = this.notationBounds.right(), this.bounds.height = c, this.origin = new nt(this.staffLeft, -this.notationBounds.y);
  }
  draw(t) {
    var A = t.canvasCtxt;
    A.translate(this.bounds.x, this.bounds.y);
    var e, s = this.staffLeft, n = this.staffRight, a;
    for (A.lineWidth = Math.round(t.staffLineWeight), A.strokeStyle = t.staffLineWeight, e = -3; e <= 3; e += 2)
      a = Math.round(t.staffInterval * e) + 0.5, A.beginPath(), A.moveTo(s, a), A.lineTo(n, a), A.stroke();
    for (e = 0; e < this.ledgerLines.length; e++) {
      var r = this.ledgerLines[e];
      a = t.calculateHeightFromStaffPosition(r.staffPosition), A.beginPath(), A.moveTo(r.x1, a), A.lineTo(r.x2, a), A.stroke();
    }
    this.notationsStartIndex === 0 && (this.score.dropCap !== null && this.score.dropCap.draw(t), this.score.annotation !== null && this.score.annotation.draw(t));
    var c = this.score.notations, g = this.notationsStartIndex + this.numNotationsOnLine;
    for (e = this.notationsStartIndex; e < g; e++)
      c[e].draw(t);
    this.startingClef.draw(t), this.custos && this.custos.draw(t), A.translate(-this.bounds.x, -this.bounds.y);
  }
  createSvgFragment(t) {
    var A = "", e, s = this.staffLeft, n = this.staffRight;
    for (e = -3; e <= 3; e += 2)
      A += I.createFragment("line", {
        x1: s,
        y1: t.staffInterval * e,
        x2: n,
        y2: t.staffInterval * e,
        stroke: t.staffLineColor,
        "stroke-width": t.staffLineWeight,
        class: "staffLine"
      });
    for (e = 0; e < this.ledgerLines.length; e++) {
      var a = this.ledgerLines[e], r = t.calculateHeightFromStaffPosition(a.staffPosition);
      A += I.createFragment("line", {
        x1: a.x1,
        y1: r,
        x2: a.x2,
        y2: r,
        stroke: t.staffLineColor,
        "stroke-width": t.staffLineWeight,
        class: "ledgerLine"
      });
    }
    for (e = 0; e < this.braces.length; e++)
      A += this.braces[e].createSvgFragment(t);
    this.notationsStartIndex === 0 && (this.score.dropCap !== null && (A += this.score.dropCap.createSvgFragment(t)), this.score.annotation !== null && (A += this.score.annotation.createSvgFragment(t))), A += this.startingClef.createSvgFragment(t);
    var c = this.score.notations, g = this.notationsStartIndex + this.numNotationsOnLine;
    for (e = this.notationsStartIndex; e < g; e++)
      A += c[e].createSvgFragment(t);
    return this.custos && (A += this.custos.createSvgFragment(t)), I.createFragment("g", {
      class: "chantLine",
      transform: "translate(" + this.bounds.x + "," + this.bounds.y + ")"
    }, A);
  }
  // code below based on code by: https://gist.github.com/alexhornbake
  //
  // optimized for braces that are only drawn horizontally.
  // returns svg path string ready to insert into svg doc
  generateCurlyBraceDrawable(t, A, e, s, n) {
    var a;
    n ? a = -t.staffInterval / 2 : a = t.staffInterval / 2;
    var r = 0.6, c = e - A, g = A, h = s + r * a, f = A + 0.25 * c, d = s + (1 - r) * a, B = A + 0.5 * c, v = s + a, Q = e, M = s + r * a, E = A + 0.75 * c, Y = s + (1 - r) * a, q = "M " + A + " " + s + " Q " + g + " " + h + " " + f + " " + d + " T " + B + " " + v + " M " + e + " " + s + " Q " + Q + " " + M + " " + E + " " + Y + " T " + B + " " + v;
    return I.createFragment("path", {
      d: q,
      stroke: t.neumeLineColor,
      "stroke-width": t.neumeLineWeight + "px",
      fill: "none"
    });
  }
  buildFromChantNotationIndex(t, A, e) {
    var s = this.score.notations;
    if (this.notationsStartIndex = A, this.numNotationsOnLine = 0, this.staffLeft = 0, e > 0 ? this.staffRight = e : this.staffRight = 99999999, this.notationsStartIndex === 0) {
      var n = 0;
      this.score.dropCap !== null && (n = this.score.dropCap.bounds.width + this.score.dropCap.padding * 2), this.score.annotation !== null && (n = Math.max(n, this.score.annotation.bounds.width + this.score.annotation.padding * 4)), this.staffLeft += n;
    }
    s[A].isClef && (t.activeClef = s[A].clone(), A++, this.notationsStartIndex++), this.startingClef = t.activeClef.clone(), this.startingClef.performLayout(t), this.startingClef.bounds.x = this.staffLeft;
    var a = this.startingClef, r = null, c = null, g = this.staffRight - it.CustosLong.bounds.width * t.glyphScaling - t.intraNeumeSpacing * 4, h, f, d = s.length - 1;
    for (h = A; h <= d; h++) {
      a.hasLyrics() && (c = a), r = a, a = s[h];
      var B;
      h === d ? B = this.staffRight : h === d - 1 ? B = Math.max(g, this.staffRight - s[d].bounds.width) : B = g;
      var v = this.positionNotationElement(t, c, r, a, B);
      if (v === !1) {
        var Q = a.notes && a.notes.reduce(function(k, Z, F) {
          return k || Z.braceEnd && F + 1 || 0;
        }, 0), M = a.notes && a.notes.reduce(function(k, Z, F) {
          return k || Z.braceStart && F + 1 || 0;
        }, 0);
        if (Q && (!M || M > Q)) {
          var E = s.slice(this.notationsStartIndex, h).reduceRight(function(k, Z, F) {
            if (k === -1 && Z.notes) {
              var X = Z.notes.filter(function(H) {
                return H.braceStart;
              }).length, ot = Z.notes.filter(function(H) {
                return H.braceEnd;
              }).length;
              if (ot) return -2;
              if (X) return F;
            }
            return k;
          }, -1);
          E > 0 && (this.numNotationsOnLine = E, h = E + this.notationsStartIndex);
        }
        for (f = h - 1; f > this.notationsStartIndex; f--) {
          var Y = s[f];
          if (Y.keepWithNext === !0 || f === h - 1 && a.isDivider)
            this.numNotationsOnLine--;
          else
            break;
        }
        break;
      }
      if (a.chantLine = this, this.numNotationsOnLine++, a.isClef && (t.activeClef = a), a.constructor === tt && e > 0) {
        this.justify = a.justify;
        break;
      }
    }
    for (h = this.notationsStartIndex + this.numNotationsOnLine; h < s.length; h++) {
      var q = s[h];
      if (q.isNeume) {
        this.custos = new O(!0), t.currNotationIndex = h - 1, this.custos.performLayout(t), this.custos.bounds.x = this.staffRight - this.custos.bounds.width - this.custos.leadingSpace;
        break;
      }
    }
    var L = s[this.notationsStartIndex + this.numNotationsOnLine - 1];
    e <= 0 ? (this.staffRight = L.bounds.right(), this.justify = !1) : this.notationsStartIndex + this.numNotationsOnLine === s.length && (this.justify = !0, this.justify = L.isDivider && (this.staffRight - L.bounds.right()) / this.staffRight < 0.1), this.justify === !0 && this.justifyElements(), this.finishLayout(t);
  }
  justifyElements() {
    var t, A = [], e = this.score.notations, s = this.notationsStartIndex + this.numNotationsOnLine, n = 0;
    if (this.numNotationsOnLine > 0) {
      var a = e[s - 1], r = null;
      for (t = s - 1; t >= this.notationsStartIndex; t--)
        if (e[t].hasLyrics()) {
          r = e[t];
          break;
        }
      r ? n = this.staffRight - Math.max(r.getAllLyricsRight(), a.bounds.right() + a.trailingSpace) : n = this.staffRight - (a.bounds.right() + a.trailingSpace);
    }
    if (this.custos && (n -= this.custos.bounds.width + this.custos.leadingSpace), !(n <= 0)) {
      var c = null, g = null, h = null;
      for (t = this.notationsStartIndex; t < s; t++)
        g !== null && g.hasLyrics() && (h = g), c = g, g = e[t], !(c !== null && c.keepWithNext === !0) && (h !== null && h.lyrics[0].allowsConnector() && !h.lyrics[0].needsConnector || g.constructor !== tt && A.push(g));
      if (A.length !== 0) {
        var f = 0, d = n / A.length, B = 0;
        for (t = this.notationsStartIndex; t < s; t++)
          g = e[t], B < A.length && A[B] === g && (f += d, B++), g.bounds.x += f;
      }
    }
  }
  finishLayout(t) {
    this.ledgerLines = [];
    for (var A = this.score.notations, e = this.notationsStartIndex + this.numNotationsOnLine, s = (F, X = 0, ot = 0) => {
      var H = F.staffPosition;
      if (H >= 5 || H <= -5) {
        var _ = X + F.bounds.x - t.intraNeumeSpacing, P = X + F.bounds.x + F.bounds.width + t.intraNeumeSpacing;
        H > 0 ? H = H - (H - 1) % 2 : H = H - (H + 1) % 2;
        var Bt = t.staffInterval * 5;
        if (this.ledgerLines.length > 0 && this.ledgerLines[this.ledgerLines.length - 1].x2 + Bt >= _) {
          var At = (_ - this.ledgerLines[this.ledgerLines.length - 1].x2) / 2;
          this.ledgerLines[this.ledgerLines.length - 1].x2 += At, _ -= At;
        }
        P > this.staffRight && (P = this.staffRight), this.ledgerLines.push({
          x1: _,
          x2: P,
          staffPosition: H
        });
      }
    }, n = [], a = null, r = 0, c = Number.MAX_VALUE, g = Number.MIN_VALUE, h = this.notationsStartIndex; h < e; h++) {
      if (c = Math.min(c, A[h].bounds.y), g = Math.max(g, A[h].bounds.bottom()), A[h].constructor === O) {
        s(A[h]);
        continue;
      }
      if (A[h].isNeume)
        for (var f = A[h], d = 0; d < f.notes.length; d++) {
          var B, v = f.notes[d];
          for (s(v, f.bounds.x, f.bounds.y), B = 0; B < v.epismata.length; B++) {
            var Q = v.epismata[B], M = 0;
            if (n.length > 0 && (M = f.bounds.x + Q.bounds.x - (n[n.length - 1].note.neume.bounds.x + n[n.length - 1].bounds.right())), n.length === 0 || n[n.length - 1].positionHint !== Q.positionHint || n[n.length - 1].terminating === !0 || n[n.length - 1].alignment === z.Left || Q.alignment === z.Right || M > t.intraNeumeSpacing * 2)
              n = [], n.push(Q);
            else {
              var E;
              if (Q.positionHint === u.Below ? E = Math.max(Q.bounds.y, n[n.length - 1].bounds.y) : E = Math.min(Q.bounds.y, n[n.length - 1].bounds.y), Q.bounds.y !== E)
                Q.bounds.y = E;
              else
                for (var Y = 0; Y < n.length; Y++)
                  n[Y].bounds.y = E;
              var q = f.bounds.x + Q.bounds.x - (n[n.length - 1].note.neume.bounds.x + n[n.length - 1].bounds.x);
              n[n.length - 1].bounds.width = q, n.push(Q);
            }
          }
          if (v.braceEnd) {
            var L, k = t.intraNeumeSpacing / 2;
            if (a !== null) {
              if (a.isAbove)
                for (L = t.calculateHeightFromStaffPosition(4), B = r; B <= h; B++)
                  L = Math.min(L, A[B].bounds.y - k);
              else
                for (L = t.calculateHeightFromStaffPosition(-4), B = r; B <= h; B++)
                  L = Math.max(L, A[B].bounds.y + k);
              var Z = !1;
              a.shape === $.RoundBrace ? this.braces.push(new AA(
                t,
                a.getAttachmentX(),
                v.braceEnd.getAttachmentX(),
                L,
                a.isAbove
              )) : (a.shape === $.AccentedCurlyBrace && (Z = !0), this.braces.push(new eA(
                t,
                a.getAttachmentX(),
                v.braceEnd.getAttachmentX(),
                L,
                a.isAbove,
                Z
              )));
            }
          }
          v.braceStart && (a = v.braceStart, r = h), a !== null && (a.isAbove ? a.bounds.y = Math.min(a.bounds.y, v.bounds.y) : a.bounds.y = Math.max(a.bounds.y, v.bounds.bottom()));
        }
    }
    a !== null && (a = a), this.custos && s(this.custos);
  }
  // this is where the real core of positioning neumes takes place
  // returns true if positioning was able to fit the neume before rightNotationBoundary.
  // returns false if cannot fit before given right margin.
  // fixme: if this returns false, shouldn't we set the connectors on prev to be activated?!
  positionNotationElement(t, A, e, s, n) {
    var a;
    if (s.bounds.x = e.bounds.right() + e.trailingSpace, A === null) {
      var r = s.bounds.right() + s.trailingSpace;
      for (a = 0; a < s.lyrics.length; a++)
        s.lyrics[a].setNeedsConnector(!1), s.getLyricLeft(a) < 0 && (s.bounds.x += -s.getLyricLeft(a)), r = Math.max(r, s.getLyricRight(a));
      return !(r > n);
    }
    if (s.hasLyrics() === !1) {
      for (a = 0; a < A.lyrics.length; a++)
        A.lyrics[a] !== null && A.lyrics[a].allowsConnector() && A.lyrics[a].setNeedsConnector(!0);
      return s.bounds.right() + s.trailingSpace < n;
    }
    var c = Math.max(A.lyrics.length, s.lyrics.length);
    if (c > 1) {
      var g = Number.MIN_VALUE, h = Number.MAX_VALUE, f = Number.MIN_VALUE;
      for (a = 0; a < c; a++) {
        if (a < A.lyrics.length && A.lyrics[a] !== null) {
          var d = A.getLyricRight(a);
          A.lyrics[a].allowsConnector() ? (A.lyrics[a].setNeedsConnector(!0), d += A.lyrics[a].widthWithConnector - A.lyrics[a].widthWithoutConnector) : d += t.minLyricWordSpacing, g = Math.max(g, d);
        }
        a < s.lyrics.length && s.lyrics[a] !== null && (h = Math.min(h, s.getLyricLeft(a)), f = Math.max(f, s.getLyricRight(a)));
      }
      return g > h && (s.bounds.x += g - h, f += g - h), s.bounds.right() < n && f <= this.staffRight ? !0 : (s.bounds.x = 0, !1);
    }
    s.lyrics[0].setNeedsConnector(!1);
    var B = s.getLyricLeft(0), v = A.getLyricRight(0);
    return A.lyrics[0].allowsConnector() === !1 ? v + t.minLyricWordSpacing > B && (s.bounds.x += v + t.minLyricWordSpacing - B) : v > B ? s.bounds.x += v - B : (A.lyrics[0].setNeedsConnector(!0), v = A.getLyricRight(0), v > B && (s.bounds.x += v - B)), s.bounds.right() + s.trailingSpace < n && s.getLyricRight(0) <= this.staffRight ? !0 : (A.hasLyrics() && A.lyrics[0].allowsConnector() && A.lyrics[0].setNeedsConnector(!0), !1);
  }
}
var b = {
  None: 0,
  // flags that can be combined, though of course it
  // it doesn't make sense to combine some!
  Large: 1,
  Small: 2,
  Ascending: 4,
  Descending: 8,
  InitioDebilis: 16,
  // handy liquescent types
  LargeAscending: 5,
  LargeDescending: 9,
  SmallAscending: 6,
  SmallDescending: 10
}, m = {
  // shapes
  Default: 0,
  Virga: 1,
  Inclinatum: 2,
  Quilisma: 3,
  Stropha: 4,
  Oriscus: 5
}, G = {
  // flags which modify the shape
  // not all of them apply to every shape of course
  None: 0,
  Ascending: 1,
  Descending: 2,
  Cavum: 4,
  Stemmed: 8
};
class bt extends V {
  /**
   * @para {Pitch} pitch
   */
  constructor(t) {
    super(), typeof t < "u" ? this.pitch = t : this.pitch = null, this.glyphVisualizer = null, this.staffPosition = 0, this.liquescent = b.None, this.shape = m.Default, this.shapeModifiers = G.None, this.neume = null, this.epismata = [], this.morae = [];
  }
  setGlyph(t, A) {
    this.glyphVisualizer ? this.glyphVisualizer.setGlyph(t, A) : this.glyphVisualizer = new D(t, A), this.glyphVisualizer.setStaffPosition(t, this.staffPosition), this.bounds.x = this.glyphVisualizer.bounds.x, this.bounds.y = this.glyphVisualizer.bounds.y, this.bounds.width = this.glyphVisualizer.bounds.width, this.bounds.height = this.glyphVisualizer.bounds.height, this.origin.x = this.glyphVisualizer.origin.x, this.origin.y = this.glyphVisualizer.origin.y;
  }
  // a utility function for modifiers
  shapeModifierMatches(t) {
    return t === G.None ? this.shapeModifier === G.None : this.shapeModifier & t !== 0;
  }
  draw(t) {
    this.glyphVisualizer.bounds.x = this.bounds.x, this.glyphVisualizer.bounds.y = this.bounds.y, this.glyphVisualizer.draw(t);
  }
  createSvgFragment(t) {
    return this.glyphVisualizer.bounds.x = this.bounds.x, this.glyphVisualizer.bounds.y = this.bounds.y, this.glyphVisualizer.createSvgFragment(t);
  }
}
class ct extends K {
  constructor(t, A, e = null) {
    super(), this.isClef = !0, this.staffPosition = t, this.octave = A, this.defaultAccidental = e, this.activeAccidental = e;
  }
  resetAccidentals() {
    this.activeAccidental = this.defaultAccidental;
  }
  pitchToStaffPosition(t) {
  }
  performLayout(t) {
    t.activeClef = this, this.defaultAccidental && this.defaultAccidental.performLayout(t), super.performLayout(t);
  }
  finishLayout(t) {
    if (this.defaultAccidental) {
      var A = this.defaultAccidental.createGlyphVisualizer(t);
      A.bounds.x += this.visualizers[0].bounds.right() + t.intraNeumeSpacing, this.addVisualizer(A);
    }
    super.finishLayout(t);
  }
  static default() {
    return bA;
  }
}
class N extends ct {
  constructor(t, A, e = null) {
    super(t, A, e), this.leadingSpace = 0;
  }
  pitchToStaffPosition(t) {
    return (t.octave - this.octave) * 7 + this.staffPosition + W.stepToStaffOffset(t.step) - W.stepToStaffOffset(y.Do);
  }
  staffPositionToPitch(t) {
    var A = t - this.staffPosition, e = Math.floor(A / 7), s = W.staffOffsetToStep(A);
    return this.defaultAccidental !== null && s === this.defaultAccidental.step && (s += this.defaultAccidental.accidentalType), new W(s, this.octave + e);
  }
  performLayout(t) {
    super.performLayout(t);
    var A = new D(t, l.DoClef);
    A.setStaffPosition(t, this.staffPosition), this.addVisualizer(A), this.finishLayout(t);
  }
  clone() {
    return new N(this.staffPosition, this.octave, this.defaultAccidental);
  }
}
var bA = new N(1, 2);
class ft extends ct {
  constructor(t, A, e = null) {
    super(t, A, e), this.octave = A, this.leadingSpace = 0;
  }
  pitchToStaffPosition(t) {
    return (t.octave - this.octave) * 7 + this.staffPosition + W.stepToStaffOffset(t.step) - W.stepToStaffOffset(y.Fa);
  }
  staffPositionToPitch(t) {
    var A = t - this.staffPosition + 3, e = Math.floor(A / 7), s = W.staffOffsetToStep(A);
    return s === y.Ti && this.defaultAccidental === x.Flat && (s = y.Te), new W(s, this.octave + e);
  }
  performLayout(t) {
    super.performLayout(t);
    var A = new D(t, l.FaClef);
    A.setStaffPosition(t, this.staffPosition), this.addVisualizer(A), this.finishLayout(t);
  }
  clone() {
    return new ft(this.staffPosition, this.octave, this.defaultAccidental);
  }
}
class St extends K {
  constructor() {
    super();
  }
  performLayout(t) {
    super.performLayout(t), this.addVisualizer(new D(t, l.None)), this.origin.x = 0, this.origin.y = 0, this.finishLayout(t);
  }
}
class tt extends K {
  constructor(t) {
    super(), this.justify = t;
  }
  performLayout(t) {
    this.bounds = new R(0, 0, 0, 0);
  }
  clone() {
    var t = new tt();
    return t.justify = this.justify, t;
  }
}
class mA {
  // source can be any object type. in the case of gabc, source is a text
  // string that maps to a gabc word (e.g.: "no(g)bis(fg)").
  // notations is an array of ChantNotationElements
  constructor(t, A) {
    this.source = t, this.notations = A;
  }
}
class QA {
  // mappings is an array of ChantMappings.
  constructor(t, A = [], e) {
    this.mappings = A, this.lines = [], this.notes = [], this.startingClef = null, this.useDropCap = e, this.dropCap = null, this.annotation = null, this.compiled = !1, this.autoColoring = !0, this.needsLayout = !0, this.bounds = new R(), this.updateNotations(t);
  }
  updateNotations(t) {
    var A;
    for (this.notations = [], A = 0; A < this.mappings.length; A++)
      this.notations = this.notations.concat(this.mappings[A].notations);
    this.startingClef = null;
    var e = new N(1, 2);
    for (A = 0; A < this.notations.length; A++) {
      if (this.notations[A].isNeume) {
        this.startingClef = e;
        break;
      }
      if (this.notations[A].isClef) {
        this.startingClef = this.notations[A], this.notations.splice(A, 1);
        break;
      }
    }
    this.startingClef || (this.startingClef = e), this.useDropCap && this.recreateDropCap(t), this.needsLayout = !0;
  }
  recreateDropCap(t) {
    for (var A = 0; A < this.notations.length; A++)
      if (this.notations[A].hasLyrics() && this.notations[A].lyrics[0] !== null) {
        this.dropCap = this.notations[A].lyrics[0].generateDropCap(t);
        return;
      }
  }
  // this is the the synchronous version of performLayout that
  // process everything without yielding to any other workers/threads.
  // good for server side processing or very small chant pieces.
  performLayout(t) {
    if (this.needsLayout !== !1) {
      t.activeClef = this.startingClef, t.notations = this.notations, t.currNotationIndex = 0, this.dropCap && this.dropCap.recalculateMetrics(t), this.annotation && this.annotation.recalculateMetrics(t);
      for (var A = 0; A < this.notations.length; A++)
        this.notations[A].performLayout(t), t.currNotationIndex++;
      this.needsLayout = !1;
    }
  }
  // for web applications, probably performLayoutAsync would be more
  // apppropriate that the above performLayout, since it will process
  // the notations without locking up the UI thread.
  performLayoutAsync(t, A) {
    if (this.needsLayout === !1) {
      A && setTimeout(() => A(), 0);
      return;
    }
    t.activeClef = this.startingClef, t.notations = this.notations, t.currNotationIndex = 0, this.dropCap && this.dropCap.recalculateMetrics(t), this.annotation && this.annotation.recalculateMetrics(t), setTimeout(() => this.layoutElementsAsync(t, 0, A), 0);
  }
  layoutElementsAsync(t, A, e) {
    if (A >= this.notations.length) {
      this.needsLayout = !1, e && setTimeout(() => e(), 0);
      return;
    }
    A === 0 && (t.activeClef = this.startingClef);
    var s = (/* @__PURE__ */ new Date()).getTime() + 50;
    do {
      var n = this.notations[A];
      n.needsLayout && (t.currNotationIndex = A, n.performLayout(t)), A++;
    } while (A < this.notations.length && (/* @__PURE__ */ new Date()).getTime() < s);
    setTimeout(() => this.layoutElementsAsync(t, A, e), 0);
  }
  layoutChantLines(t, A, e) {
    this.lines = [];
    var s = 0, n = 0;
    t.activeClef = this.startingClef;
    do {
      var a = new vA(this);
      a.buildFromChantNotationIndex(t, n, A), n = a.notationsStartIndex + a.numNotationsOnLine, a.performLayout(t), this.lines.push(a), a.bounds.y = -a.bounds.y + s, s += a.bounds.height + t.staffInterval * 1.5;
    } while (n < this.notations.length);
    var r = this.lines[this.lines.length - 1];
    this.bounds.x = 0, this.bounds.y = 0, this.bounds.width = r.bounds.width, this.bounds.height = s, e && e(this);
  }
  draw(t) {
    var A = t.canvasCtxt;
    A.clearRect(0, 0, t.canvas.width, t.canvas.height), A.translate(this.bounds.x, this.bounds.y);
    for (var e = 0; e < this.lines.length; e++)
      this.lines[e].draw(t);
    A.translate(-this.bounds.x, -this.bounds.y);
  }
  createSvg(t) {
    var A = "";
    for (var e in t.defs)
      t.defs.hasOwnProperty(e) && (A += t.defs[e]);
    A = I.createFragment("defs", {}, A);
    for (var s = 0; s < this.lines.length; s++)
      A += this.lines[s].createSvgFragment(t);
    return A = I.createFragment("g", {}, A), A = I.createFragment("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      version: "1.1",
      "xmlns:xlink": "http://www.w3.org/1999/xlink",
      class: "ChantScore",
      width: this.bounds.width,
      height: this.bounds.height
    }, A), A;
  }
  unserializeFromJson(t) {
    this.autoColoring = t["auto-coloring"], t.annotation !== null && t.annotation !== "" ? this.annotation = new qt(ctxt, t.annotation) : this.annotation = null;
    var A = t["drop-cap"] === "auto";
    Xt.parseChantNotations(t.notations, this, A);
  }
  serializeToJson() {
    var t = {};
    return t.type = "score", t["auto-coloring"] = !0, this.annotation !== null ? t.annotation = this.annotation.unsanitizedText : t.annotation = "", t;
  }
}
class kA {
  constructor() {
    var t = {
      layout: {
        units: "mm",
        "default-font": {
          "font-family": "Crimson",
          "font-size": 14
        },
        page: {
          width: 8.5,
          height: 11,
          "margin-left": 0,
          "margin-top": 0,
          "margin-right": 0,
          "margin-bottom": 0
        }
      },
      scores: []
    };
    this.copyLayout(this, t), this.scores = t.scores;
  }
  copyLayout(t, A) {
    t.layout = {
      units: A.layout.units,
      "default-font": {
        "font-family": A.layout["default-font"]["font-family"],
        "font-size": A.layout["default-font"]["font-size"]
      },
      page: {
        width: A.layout.page.width,
        height: A.layout.page.height,
        "margin-left": A.layout.page["margin-left"],
        "margin-top": A.layout.page["margin-top"],
        "margin-right": A.layout.page["margin-right"],
        "margin-bottom": A.layout.page["margin-bottom"]
      }
    };
  }
  unserializeFromJson(t) {
    this.copyLayout(this, t), this.scores = [];
    for (var A = 0; A < t.scores.length; A++) {
      var e = new QA();
      e.unserializeFromJson(t.scores[A]), this.scores.push(e);
    }
  }
  serializeToJson() {
    var t = {};
    this.copyLayout(t, this), t.scores = [];
    for (var A = 0; A < this.scores.length; A++)
      t.scores.push(this.scores[A].serializeToJson());
    return t;
  }
}
class wA {
  constructor(t, A, e = 0) {
    this.ctxt = t, this.neume = A, this.x = e, this.lastNote = null, this.lineIsHanging = !1;
  }
  // used to start a hanging line on the left of the next note
  lineFrom(t) {
    return this.lastNote = t, this.lineIsHanging = !0, this;
  }
  // add a note, with a connecting line on the left if we have one
  noteAt(t, A, e = !0) {
    if (!t)
      throw "NeumeBuilder.noteAt: note must be a valid note";
    if (!A)
      throw "NeumeBuilder.noteAt: glyph must be a valid glyph code";
    t.setGlyph(this.ctxt, A);
    var s = t.glyphVisualizer.align === "right", n = e && this.lastNote !== null && (this.lineIsHanging || this.lastNote.glyphVisualizer.align === "right" || Math.abs(this.lastNote.staffPosition - t.staffPosition) > 1);
    if (n) {
      var a = new pt(this.ctxt, this.lastNote, t, this.lineIsHanging);
      this.neume.addVisualizer(a), a.bounds.x = Math.max(0, this.x - a.bounds.width), s || (this.x = a.bounds.x);
    }
    return s && this.lastNote ? t.bounds.x = this.x - t.bounds.width : (t.bounds.x = this.x, this.x += t.bounds.width), this.neume.addVisualizer(t), this.lastNote = t, this.lineIsHanging = !1, this;
  }
  // a special form of noteAdd that creates a virga
  // uses a punctum cuadratum and a line rather than the virga glyphs
  virgaAt(t, A = !0) {
    this.noteAt(t, l.PunctumQuadratum);
    var e = new tA(this.ctxt, t);
    return this.x -= e.bounds.width, e.bounds.x = this.x, this.neume.addVisualizer(e), this.lastNote = t, this.lineIsHanging = !1, this;
  }
  advanceBy(t) {
    return this.lastNote = null, this.lineIsHanging = !1, this.x += t, this;
  }
  // for terminating hanging lines with no lower notes
  withLineEndingAt(t) {
    if (this.lastNote !== null) {
      var A = new pt(this.ctxt, this.lastNote, t, !0);
      return this.neume.addVisualizer(A), this.x -= A.bounds.width, A.bounds.x = this.x, this.neume.addVisualizer(A), this.lastNote = t, this;
    }
  }
  withPodatus(t, A) {
    var e, s;
    return t.liquescent === b.InitioDebilis ? (A.liquescent === b.None ? e = l.PunctumQuadratum : e = l.PunctumQuadratumDesLiquescent, s = l.TerminatingDesLiquescent) : A.liquescent & b.Small ? (s = l.BeginningAscLiquescent, e = l.TerminatingAscLiquescent) : A.liquescent & b.Ascending ? (s = l.PunctumQuadratum, e = l.PunctumQuadratumAscLiquescent) : A.liquescent & b.Descending ? (s = l.PunctumQuadratum, e = l.PunctumQuadratumDesLiquescent) : (s = l.PodatusLower, e = l.PodatusUpper), t.shape === m.Quilisma && (s = l.Quilisma), this.noteAt(t, s).noteAt(A, e), this.lastNote = null, this;
  }
  withClivis(t, A) {
    var e;
    return t.shape === m.Oriscus ? this.noteAt(t, l.OriscusDes, !1) : this.lineFrom(A).noteAt(t, l.PunctumQuadratum), A.liquescent & b.Small ? e = l.TerminatingDesLiquescent : A.liquescent === b.Ascending ? e = l.PunctumQuadratumAscLiquescent : A.liquescent === b.Descending ? e = l.PunctumQuadratumDesLiquescent : e = l.PunctumQuadratum, this.noteAt(A, e), this.lastNote = null, this;
  }
  // lays out a sequence of notes that are inclinati (e.g., climacus, pes subpunctis)
  withInclinati(t) {
    for (var A = t[0].staffPosition, e = t[0].staffPosition, s = it.PunctumInclinatum.bounds.width * this.ctxt.glyphScaling, n = 0; n < t.length; n++, e = A) {
      var a = t[n];
      a.liquescent & b.Small ? a.setGlyph(this.ctxt, l.PunctumInclinatumLiquescent) : a.liquescent & b.Large ? a.setGlyph(this.ctxt, l.Stropha) : a.setGlyph(this.ctxt, l.PunctumInclinatum), A = a.staffPosition;
      var r;
      switch (Math.abs(e - A)) {
        case 0:
          r = 1.1;
          break;
        case 1:
          r = 0.8;
          break;
        default:
          r = 1.2;
          break;
      }
      n > 0 && (this.x += s * r), a.bounds.x = this.x, this.neume.addVisualizer(a);
    }
    return this;
  }
  withPorrectusSwash(t, A) {
    var e = this.lastNote !== null && (this.lineIsHanging || this.lastNote.glyphVisualizer.align === "right" || Math.abs(this.lastNote.staffPosition - t.staffPosition) > 1);
    if (e) {
      var s = new pt(this.ctxt, this.lastNote, t, this.lineIsHanging);
      this.x = Math.max(0, this.x - s.bounds.width), s.bounds.x = this.x, this.neume.addVisualizer(s);
    }
    var n;
    switch (t.staffPosition - A.staffPosition) {
      case 1:
        n = l.Porrectus1;
        break;
      case 2:
        n = l.Porrectus2;
        break;
      case 3:
        n = l.Porrectus3;
        break;
      case 4:
        n = l.Porrectus4;
        break;
      default:
        n = l.None;
        break;
    }
    return t.setGlyph(this.ctxt, n), t.bounds.x = this.x, A.setGlyph(this.ctxt, l.None), this.x = t.bounds.right(), A.bounds.x = this.x - A.bounds.width, this.neume.addVisualizer(t), this.neume.addVisualizer(A), this.lastNote = A, this.lineIsHanging = !1, this;
  }
}
class C extends K {
  constructor(t = []) {
    super(), this.isNeume = !0, this.notes = t;
    for (var A = 0; A < t.length; A++)
      t[A].neume = this;
  }
  addNote(t) {
    t.neume = this, this.notes.push(t);
  }
  performLayout(t) {
    super.performLayout(t);
  }
  finishLayout(t) {
    this.positionMarkings();
    for (var A = 0; A < this.notes.length; A++) {
      var e = this.notes[A], s;
      for (s = 0; s < e.epismata.length; s++)
        e.epismata[s].performLayout(t), this.addVisualizer(e.epismata[s]);
      for (s = 0; s < e.morae.length; s++)
        e.morae[s].performLayout(t), this.addVisualizer(e.morae[s]);
      e.ictus && (e.ictus.performLayout(t), this.addVisualizer(e.ictus)), e.acuteAccent && (e.acuteAccent.performLayout(t), this.addVisualizer(e.acuteAccent));
    }
    this.origin.x = this.notes[0].origin.x, this.origin.y = this.notes[0].origin.y, super.finishLayout(t);
  }
  resetDependencies() {
  }
  build(t) {
    return new wA(t, this);
  }
  // subclasses can override this in order to correctly place markings in a neume specific way
  positionMarkings() {
  }
}
class T extends C {
  positionMarkings() {
    for (var t = u.Above, A = 0; A < this.notes[0].epismata.length; A++)
      this.notes[0].epismata[A].positionHint === u.Default ? this.notes[0].epismata[A].positionHint = t : t = this.notes[0].epismata[A].positionHint, t = t === u.Above ? u.Below : u.Above;
  }
  performLayout(t) {
    super.performLayout(t), t.calculateHeightFromStaffPosition(4), this.build(t).noteAt(this.notes[0], T.getNoteGlyphCode(this.notes[0])), this.finishLayout(t);
  }
  static getNoteGlyphCode(t) {
    return t.shape === m.Stropha ? l.Stropha : t.liquescent !== b.None ? l.StrophaLiquescent : t.shapeModifiers & G.Cavum ? l.PunctumCavum : l.PunctumQuadratum;
  }
}
class Ht extends C {
  positionMarkings() {
    var t, A;
    for (t = 0; t < this.notes.length; t++) {
      var e = u.Above;
      for (A = 0; A < this.notes[t].epismata.length; A++)
        this.notes[t].epismata[A].positionHint === u.Default ? this.notes[t].epismata[A].positionHint = e : e = this.notes[t].epismata[A].positionHint, e = e === u.Above ? u.Below : u.Above;
    }
  }
  performLayout(t) {
    super.performLayout(t), this.build(t).virgaAt(this.notes[0]).advanceBy(t.intraNeumeSpacing).virgaAt(this.notes[1]), this.finishLayout(t);
  }
}
class yA extends C {
  positionMarkings() {
    var t, A;
    for (t = 0; t < this.notes.length; t++) {
      var e = u.Above;
      for (A = 0; A < this.notes[t].epismata.length; A++)
        this.notes[t].epismata[A].positionHint === u.Default ? this.notes[t].epismata[A].positionHint = e : e = this.notes[t].epismata[A].positionHint, e = e === u.Above ? u.Below : u.Above;
    }
  }
  performLayout(t) {
    super.performLayout(t), this.build(t).virgaAt(this.notes[0]).advanceBy(t.intraNeumeSpacing).virgaAt(this.notes[1]).advanceBy(t.intraNeumeSpacing).virgaAt(this.notes[2]), this.finishLayout(t);
  }
}
class Lt extends C {
  positionMarkings() {
    for (var t = 0; t < this.notes.length; t++)
      for (var A = 0; A < this.notes[t].epismata.length; A++) {
        var e = this.notes[t].epismata[A];
        e.positionHint === u.Default && (e.positionHint = u.Above);
      }
  }
  performLayout(t) {
    super.performLayout(t), this.build(t).virgaAt(this.notes[0]).advanceBy(t.intraNeumeSpacing / 2).withInclinati(this.notes.slice(1)), this.finishLayout(t);
  }
}
class mt extends C {
  positionMarkings() {
    var t, A;
    for (A = 0; A < this.notes[1].morae.length; A++)
      t = this.notes[1].morae[A], this.notes[0].staffPosition - this.notes[1].staffPosition === 1 && Math.abs(this.notes[1].staffPosition % 2) === 1 && (t.positionHint = u.Below);
    for (A = 0; A < this.notes[0].morae.length; A++)
      ;
    for (A = 0; A < this.notes[0].epismata.length; A++)
      t = this.notes[0].epismata[A], t.positionHint === u.Default && (t.positionHint = u.Above);
    for (A = 0; A < this.notes[1].epismata.length; A++)
      t = this.notes[1].epismata[A], t.positionHint === u.Default && (t.positionHint = u.Above);
  }
  performLayout(t) {
    super.performLayout(t);
    var A = this.notes[0], e = this.notes[1];
    this.build(t).withClivis(A, e), this.finishLayout(t);
  }
}
class Mt extends C {
  positionMarkings() {
    for (var t = 0; t < this.notes.length; t++)
      for (var A = u.Above, e = 0; e < this.notes[t].epismata.length; e++)
        this.notes[t].epismata[e].positionHint === u.Default ? this.notes[t].epismata[e].positionHint = A : A = this.notes[t].epismata[e].positionHint, A = A === u.Above ? u.Below : u.Above;
  }
  performLayout(t) {
    super.performLayout(t), this.build(t).noteAt(this.notes[0], T.getNoteGlyphCode(this.notes[0])).advanceBy(t.intraNeumeSpacing).noteAt(this.notes[1], T.getNoteGlyphCode(this.notes[1])), this.finishLayout(t);
  }
}
class Et extends C {
  positionMarkings() {
    for (var t = u.Above, A = 0; A < this.notes[0].epismata.length; A++)
      this.notes[0].epismata[A].positionHint === u.Default ? this.notes[0].epismata[A].positionHint = t : t = this.notes[0].epismata[A].positionHint, t = t === u.Above ? u.Below : u.Above;
  }
  performLayout(t) {
    super.performLayout(t);
    var A = this.notes[0], e;
    if (A.liquescent !== b.None)
      e = l.OriscusLiquescent;
    else if (A.shapeModifiers & G.Ascending)
      e = l.OriscusAsc;
    else if (A.shapeModifiers & G.Descending)
      e = l.OriscusDes;
    else {
      e = l.OriscusDes;
      var s = t.findNextNeume();
      if (s) {
        var n = t.activeClef.pitchToStaffPosition(s.notes[0].pitch);
        n > A.staffPosition && (e = l.OriscusAsc);
      }
    }
    this.build(t).noteAt(A, e), this.finishLayout(t);
  }
  resetDependencies() {
    this.notes[0].shapeModifiers & G.Ascending || this.notes[0].shapeModifiers & G.Descending || (this.needsLayout = !0);
  }
}
class CA extends C {
  performLayout(t) {
    super.performLayout(t);
    var A = this.notes[0], e = this.notes[1], s, n = A.staffPosition, a = e.staffPosition;
    A.shape === m.Oriscus ? s = l.OriscusAsc : s = l.PunctumQuadratum;
    var r = this.build(t).noteAt(A, s);
    a - n === 1 ? r.virgaAt(e) : e.liquescent === b.LargeDescending ? r.noteAt(e, l.PunctumQuadratumDesLiquescent).withLineEndingAt(A) : r.noteAt(e, l.PunctumQuadratum).withLineEndingAt(A), this.finishLayout(t);
  }
}
class Zt extends C {
  performLayout(t) {
    super.performLayout(t), this.build(t).withPodatus(this.notes[0], this.notes[1]).advanceBy(t.intraNeumeSpacing / 2).withInclinati(this.notes.slice(2)), this.finishLayout(t);
  }
}
class Qt extends C {
  positionMarkings() {
    var t, A;
    for (A = 0; A < this.notes[0].epismata.length; A++)
      this.notes[0].epismata[A].positionHint === u.Default && (this.notes[0].epismata[A].positionHint = u.Below);
    if (this.notes[0].morae.length < 2)
      for (A = 0; A < this.notes[0].morae.length; A++)
        t = this.notes[0].morae[A], this.notes[1].staffPosition - this.notes[0].staffPosition === 1 && Math.abs(this.notes[0].staffPosition % 2) === 1 && (t.positionHint = u.Below);
    for (A = 0; A < this.notes[1].epismata.length; A++)
      this.notes[1].epismata[A].positionHint === u.Default && (this.notes[1].epismata[A].positionHint = u.Above);
  }
  performLayout(t) {
    super.performLayout(t), this.build(t).withPodatus(this.notes[0], this.notes[1]), this.finishLayout(t);
  }
}
class Ft extends C {
  performLayout(t) {
    super.performLayout(t);
    var A = this.notes[0], e = this.notes[1], s = this.notes[2], n;
    s.liquescent & b.Small ? n = l.TerminatingAscLiquescent : s.liquescent & b.Descending ? n = l.PunctumQuadratumDesLiquescent : n = l.PodatusUpper, this.build(t).lineFrom(e).withPorrectusSwash(A, e).noteAt(s, n), this.finishLayout(t);
  }
}
class GA extends C {
  performLayout(t) {
    super.performLayout(t);
    var A = this.notes[0], e = this.notes[1], s = this.notes[2], n = this.notes[3], a = l.PunctumQuadratum, r;
    n.liquescent & b.Small ? (a = l.PunctumQuadratumDesLiquescent, r = l.TerminatingDesLiquescent) : n.liquescent & b.Ascending ? r = l.PunctumQuadratumAscLiquescent : n.liquescent & b.Descending ? r = l.PunctumQuadratumDesLiquescent : r = l.PunctumQuadratum, this.build(t).lineFrom(e).withPorrectusSwash(A, e).noteAt(s, a).noteAt(n, r), this.finishLayout(t);
  }
}
class Ut extends C {
  performLayout(t) {
    super.performLayout(t), this.build(t).withInclinati(this.notes), this.finishLayout(t);
  }
}
class wt extends C {
  positionMarkings() {
    var t, A = u.Above;
    for (t = 0; t < this.notes[0].epismata.length; t++)
      this.notes[0].epismata[t].positionHint === u.Default ? this.notes[0].epismata[t].positionHint = A : A = this.notes[0].epismata[t].positionHint, A = A === u.Above ? u.Below : u.Above;
  }
  performLayout(t) {
    super.performLayout(t);
    var A = this.notes[0], e = l.PunctumQuadratum;
    A.liquescent !== b.None ? A.shape === m.Inclinatum ? e = l.PunctumInclinatumLiquescent : A.shape === m.Oriscus ? e = l.OriscusLiquescent : A.liquescent & b.Ascending ? e = l.PunctumQuadratumAscLiquescent : A.liquescent & b.Descending && (e = l.PunctumQuadratumDesLiquescent) : A.shapeModifiers & G.Cavum ? e = l.PunctumCavum : A.shape === m.Inclinatum ? e = l.PunctumInclinatum : A.shape === m.Quilisma ? e = l.Quilisma : e = l.PunctumQuadratum, this.build(t).noteAt(A, e), this.finishLayout(t);
  }
}
class Vt extends C {
  positionMarkings() {
    var t, A;
    for (t = 0; t < this.notes.length; t++)
      for (A = 0; A < this.notes[t].epismata.length; A++)
        this.notes[t].epismata[A].positionHint === u.Default && (this.notes[t].epismata[A].positionHint = u.Below);
  }
  performLayout(t) {
    super.performLayout(t);
    var A = this.notes[0], e = this.notes[1], s = this.notes[2], n = this.build(t).noteAt(A, l.PunctumQuadratum);
    e.shapeModifiers & G.Stemmed || n.advanceBy(t.intraNeumeSpacing), n.noteAt(e, l.OriscusAsc), s.liquescent & b.Small ? n.noteAt(s, l.TerminatingAscLiquescent) : s.liquescent === b.Ascending ? n.noteAt(s, l.PunctumQuadratumAscLiquescent) : s.liquescent === b.Descending ? n.noteAt(s, l.PunctumQuadratumDesLiquescent) : n.virgaAt(s), this.finishLayout(t);
  }
}
class kt extends C {
  positionMarkings() {
    var t, A;
    for (t = 0; t < this.notes.length; t++)
      for (A = 0; A < this.notes[t].epismata.length; A++)
        this.notes[t].epismata[A].positionHint === u.Default && (this.notes[t].epismata[A].positionHint = u.Below);
  }
  performLayout(t) {
    super.performLayout(t);
    var A = this.notes[0], e = this.notes[1], s = this.notes[2], n = this.notes[3], a = this.build(t).noteAt(A, l.PunctumQuadratum);
    e.shapeModifiers & G.Stemmed || a.advanceBy(t.intraNeumeSpacing), a.noteAt(e, l.OriscusAsc), n.liquescent & b.Small ? a.noteAt(s, l.PunctumQuadratumDesLiquescent) : a.noteAt(s, l.PunctumQuadratum), n.liquescent & b.Small ? a.noteAt(n, l.TerminatingDesLiquescent) : n.liquescent & b.Ascending ? a.noteAt(n, l.PunctumQuadratumAscLiquescent) : n.liquescent & b.Descending ? a.noteAt(n, l.PunctumQuadratumDesLiquescent) : a.noteAt(n, l.PunctumQuadratum), this.finishLayout(t);
  }
}
class xt extends C {
  positionMarkings() {
    var t;
    for (t = 0; t < this.notes[0].epismata.length; t++)
      this.notes[0].epismata[t].positionHint === u.Default && (this.notes[0].epismata[t].positionHint = u.Below);
    var A = this.notes[2].shape === m.Virga ? u.Above : u.Below;
    for (t = 0; t < this.notes[1].epismata.length; t++)
      this.notes[1].epismata[t].positionHint === u.Default && (this.notes[1].epismata[t].positionHint = A);
    for (t = 0; t < this.notes[2].epismata.length; t++)
      this.notes[2].epismata[t].positionHint === u.Default && (this.notes[2].epismata[t].positionHint = u.Above);
  }
  // if the third note shape is a virga, then the scadicus is rendered
  // as a podatus followed by a virga. Otherwise, it's rendered as a
  // punctum followed by a podatus...
  performLayout(t) {
    super.performLayout(t);
    var A = this.notes[0], e = this.notes[1], s = this.notes[2];
    s.shape === m.Virga ? this.build(t).withPodatus(A, e).virgaAt(s) : this.build(t).noteAt(A, l.PunctumQuadratum).withPodatus(e, s), this.finishLayout(t);
  }
}
class Dt extends C {
  positionMarkings() {
    var t;
    for (t = 0; t < this.notes[0].epismata.length; t++)
      this.notes[0].epismata[t].positionHint === u.Default && (this.notes[0].epismata[t].positionHint = u.Below);
    var A = this.notes[2].shape === m.Virga ? u.Above : u.Below;
    for (t = 0; t < this.notes[1].epismata.length; t++)
      this.notes[1].epismata[t].positionHint === u.Default && (this.notes[1].epismata[t].positionHint = A);
    for (t = 0; t < this.notes[2].epismata.length; t++)
      this.notes[2].epismata[t].positionHint === u.Default && (this.notes[2].epismata[t].positionHint = u.Above);
    for (t = 0; t < this.notes[3].epismata.length; t++)
      this.notes[3].epismata[t].positionHint === u.Default && (this.notes[3].epismata[t].positionHint = u.Above);
  }
  performLayout(t) {
    super.performLayout(t);
    var A = this.notes[0], e = this.notes[1], s = this.notes[2], n = this.notes[3];
    if (s.shape === m.Virga)
      this.build(t).withPodatus(A, e).advanceBy(t.intraNeumeSpacing).withClivis(s, n);
    else {
      var a = l.PunctumQuadratum;
      n.liquescent & b.Ascending ? a = l.PunctumQuadratumAscLiquescent : n.liquescent & b.Descending && (a = l.PunctumQuadratumDesLiquescent), this.build(t).noteAt(A, l.PunctumQuadratum).withPodatus(e, s).advanceBy(t.intraNeumeSpacing).noteAt(n, a);
    }
    this.finishLayout(t);
  }
}
class Pt extends C {
  positionMarkings() {
    var t, A, e = !1;
    for (A = 0; A < this.notes[1].epismata.length; A++)
      t = this.notes[1].epismata[A], t.positionHint === u.Default && (t.positionHint = u.Above, e = !0);
    for (A = 0; A < this.notes[0].epismata.length; A++)
      t = this.notes[0].epismata[A], t.positionHint === u.Default && (t.positionHint = e ? u.Above : u.Below);
    for (A = 0; A < this.notes[2].epismata.length; A++)
      t = this.notes[2].epismata[A], t.positionHint === u.Default && (t.positionHint = e ? u.Above : u.Below);
  }
  performLayout(t) {
    super.performLayout(t);
    var A = this.notes[0], e = this.notes[1], s = this.notes[2], n, a;
    A.liquescent === b.InitioDebilis ? n = l.TerminatingDesLiquescent : A.shape === m.Quilisma ? n = l.Quilisma : n = l.PunctumQuadratum, s.liquescent & b.Small ? a = l.TerminatingDesLiquescent : s.liquescent & b.Ascending ? a = l.PunctumQuadratumAscLiquescent : s.liquescent & b.Descending ? a = l.PunctumQuadratumDesLiquescent : a = l.PunctumQuadratum, this.build(t).noteAt(A, n).noteAt(e, l.PunctumQuadratum).noteAt(s, a), this.finishLayout(t);
  }
}
class Nt extends C {
  positionMarkings() {
    var t, A, e = !1;
    for (A = 0; A < this.notes[1].epismata.length; A++)
      t = this.notes[1].epismata[A], t.positionHint === u.Default && (t.positionHint = u.Above, e = !0);
    for (A = 0; A < this.notes[0].epismata.length; A++)
      t = this.notes[0].epismata[A], t.positionHint === u.Default && (t.positionHint = e ? u.Above : u.Below);
    for (A = 0; A < this.notes[2].epismata.length; A++)
      t = this.notes[2].epismata[A], t.positionHint === u.Default && (t.positionHint = e ? u.Above : u.Below);
    for (A = 0; A < this.notes[3].epismata.length; A++)
      t = this.notes[3].epismata[A], t.positionHint === u.Default && (t.positionHint = u.Above);
  }
  performLayout(t) {
    super.performLayout(t);
    var A = this.notes[0], e = this.notes[1], s = this.notes[2], n = this.notes[3], a, r;
    A.liquescent === b.InitioDebilis ? a = l.TerminatingDesLiquescent : A.shape === m.Quilisma ? a = l.Quilisma : a = l.PunctumQuadratum, n.liquescent & b.Small ? r = l.TerminatingAscLiquescent : s.liquescent & b.Descending ? r = l.PunctumQuadratumDesLiquescent : r = l.PodatusUpper, this.build(t).noteAt(A, a).withPorrectusSwash(e, s).noteAt(n, r), this.finishLayout(t);
  }
}
class IA extends C {
  positionMarkings() {
    var t, A, e = !1;
    for (A = 0; A < this.notes[1].epismata.length; A++)
      t = this.notes[1].epismata[A], t.positionHint === u.Default && (t.positionHint = u.Above, e = !0);
    for (A = 0; A < this.notes[0].epismata.length; A++)
      t = this.notes[0].epismata[A], t.positionHint === u.Default && (t.positionHint = e ? u.Above : u.Below);
    for (A = 0; A < this.notes[2].epismata.length; A++)
      t = this.notes[2].epismata[A], t.positionHint === u.Default && (t.positionHint = e ? u.Above : u.Below);
    for (A = 0; A < this.notes[3].epismata.length; A++)
      t = this.notes[3].epismata[A], t.positionHint === u.Default && (t.positionHint = u.Above);
    for (A = 0; A < this.notes[4].epismata.length; A++)
      t = this.notes[4].epismata[A], t.positionHint === u.Default && (t.positionHint = u.Above);
  }
  performLayout(t) {
    super.performLayout(t);
    var A = this.notes[0], e = this.notes[1], s = this.notes[2], n = this.notes[3], a = this.notes[4], r, c = l.PunctumQuadratum, g;
    A.liquescent === b.InitioDebilis ? r = l.TerminatingDesLiquescent : A.shape === m.Quilisma ? r = l.Quilisma : r = l.PunctumQuadratum, a.liquescent & b.Small ? (c = l.PunctumQuadratumDesLiquescent, g = l.TerminatingDesLiquescent) : a.liquescent & b.Ascending ? g = l.PunctumQuadratumAscLiquescent : a.liquescent & b.Descending ? g = l.PunctumQuadratumDesLiquescent : g = l.PunctumQuadratum, this.build(t).noteAt(A, r).withPorrectusSwash(e, s).noteAt(n, c).noteAt(a, g), this.finishLayout(t);
  }
}
class SA extends C {
  positionMarkings() {
    var t, A;
    for (t = 0; t < this.notes.length; t++) {
      var e = u.Above;
      for (A = 0; A < this.notes[t].epismata.length; A++)
        this.notes[t].epismata[A].positionHint === u.Default ? this.notes[t].epismata[A].positionHint = e : e = this.notes[t].epismata[A].positionHint, e = e === u.Above ? u.Below : u.Above;
    }
  }
  performLayout(t) {
    super.performLayout(t), this.build(t).noteAt(this.notes[0], T.getNoteGlyphCode(this.notes[0])).advanceBy(t.intraNeumeSpacing).noteAt(this.notes[1], T.getNoteGlyphCode(this.notes[1])).advanceBy(t.intraNeumeSpacing).noteAt(this.notes[2], T.getNoteGlyphCode(this.notes[2])), this.finishLayout(t);
  }
}
class zt extends C {
  positionMarkings() {
    for (var t = u.Above, A = 0; A < this.notes[0].epismata.length; A++)
      this.notes[0].epismata[A].positionHint === u.Default ? this.notes[0].epismata[A].positionHint = t : t = this.notes[0].epismata[A].positionHint, t = t === u.Above ? u.Below : u.Above;
  }
  performLayout(t) {
    super.performLayout(t), this.build(t).virgaAt(this.notes[0]), this.finishLayout(t);
  }
}
var Tt = /(?=.)((?:[^(])*)(?:\(?([^)]*)\)?)?/g, HA = /z0|z|Z|::|:|;|,|`|c1|c2|c3|c4|f3|f4|cb3|cb4|\/\/|\/| |\!|-?[a-mA-M][oOwWvVrRsxy#~\+><_\.'012345]*(?:\[[^\]]*\]?)*/g, LA = /([ou])(b|cb|cba):([01])(?:([{}])|;(\d*(?:\.\d+)?)mm)/;
class Xt {
  // takes gabc source code (without the header info) and returns an array
  // of ChantMappings describing the chant. A chant score can then be created
  // fron the chant mappings and later updated via updateMappings() if need
  // be...
  static createMappingsFromSource(t, A) {
    var e = this.splitWords(A);
    t.activeClef = ct.default();
    var s = this.createMappingsFromWords(t, e, (n) => t.activeClef = n);
    return s.length > 0 && s[s.length - 1].notations.length > 0 && (s[s.length - 1].notations[s[s.length - 1].notations.length - 1].trailingSpace = 0), s;
  }
  // A simple general purpose diff algorithm adapted here for comparing
  // an array of existing mappings with an updated list of gabc words.
  // note before is an array of mappings, and after is an array of strings
  // (gabc words).
  //
  // This is definitely not the most effecient diff algorithm, but for our
  // limited needs and source size it seems to work just fine...
  //
  // code is adapted from: https://github.com/paulgb/simplediff
  //
  // Returns:
  //   A list of pairs, with the first part of the pair being one of three
  //   strings ('-', '+', '=') and the second part being a list of values from
  //   the original before and/or after lists. The first part of the pair
  //   corresponds to whether the list of values is a deletion, insertion, or
  //   unchanged, respectively.
  static diffDescriptorsAndNewWords(t, A) {
    var e = {}, s;
    for (s = 0; s < t.length; s++)
      e[t[s].source] = e[t[s].source] || [], e[t[s].source].push(s);
    var n = [], a, r, c, g;
    for (a = r = c = 0, g = 0; g < A.length; g++) {
      var h = [];
      for (e[A[g]] = e[A[g]] || [], s = 0; s < e[A[g]].length; s++) {
        var f = e[A[g]][s];
        h[f] = (f && n[f - 1] || 0) + 1, h[f] > c && (c = h[f], a = f - c + 1, r = g - c + 1);
      }
      n = h;
    }
    if (c === 0) {
      var d = [];
      return t.length && d.push(["-", t]), A.length && d.push(["+", A]), d;
    }
    return [].concat(
      this.diffDescriptorsAndNewWords(t.slice(0, a), A.slice(0, r)),
      [["=", A.slice(r, r + c)]],
      this.diffDescriptorsAndNewWords(t.slice(a + c), A.slice(r + c))
    );
  }
  // this function essentially performs and applies a rudimentary diff between a
  // previously parsed set of mappings and between a new gabc source text.
  // the mappings array passed in is changed in place to be updated from the
  // new source
  static updateMappingsFromSource(t, A, e) {
    A.pop();
    var s = this.splitWords(e), n = this.diffDescriptorsAndNewWords(A, s), a = 0, r, c;
    t.activeClef = ct.default();
    for (var g = 0; g < n.length; g++) {
      var h = n[g][0], f = n[g][1];
      if (h === "=")
        for (r = 0; r < f.length; r++, a++)
          for (c = 0; c < A[a].notations.length; c++)
            A[a].notations[c].resetDependencies(), A[a].notations[c].isClef && (t.activeClef = A[a].notations[c]);
      else if (h === "-")
        A.splice(a, f.length);
      else if (h === "+")
        for (r = 0; r < f.length; r++) {
          var d = this.createMappingFromWord(t, f[r]);
          for (c = 0; c < d.notations.length; c++)
            d.notations[c].isClef && (t.activeClef = d.notations[c]);
          A.splice(a++, 0, d);
        }
    }
    A.length > 0 && A[A.length - 1].notations.length > 0 && (A[A.length - 1].notations[A[A.length - 1].notations.length - 1].trailingSpace = 0);
  }
  // takes an array of gabc words (like that returned by splitWords below)
  // and returns an array of ChantMapping objects, one for each word.
  static createMappingsFromWords(t, A) {
    for (var e = [], s = 0; s < A.length; s++) {
      var n = A[s].trim();
      if (n !== "") {
        var a = this.createMappingFromWord(t, n);
        a && e.push(a);
      }
    }
    return e;
  }
  // takes a gabc word (like those returned by splitWords below) and returns
  // a ChantMapping object that contains the gabc word source text as well
  // as the generated notations.
  static createMappingFromWord(t, A) {
    for (var e = [], s = [], n = 0; r = Tt.exec(A); )
      e.push(r);
    for (var a = 0; a < e.length; a++) {
      var r = e[a], c = r[1].trim(), g = r[2], h = this.parseNotations(t, g);
      if (h.length !== 0 && (s = s.concat(h), c !== "")) {
        for (var f = null, d = 0; d < h.length; d++) {
          var B = h[d];
          if (!(B.isAccidental || B.constructor === O)) {
            f = B;
            break;
          }
        }
        if (f === null)
          return s;
        var v;
        !B.isNeume && B.constructor !== St ? v = S.Directive : n === 0 && a === e.length - 1 ? v = S.SingleSyllable : n === 0 && a < e.length - 1 ? v = S.BeginningSyllable : a === e.length - 1 ? v = S.EndingSyllable : v = S.MiddleSyllable, n++, (v === S.BeginningSyllable || v === S.SingleSyllable) && t.activeClef.resetAccidentals();
        var Q = this.createSyllableLyrics(t, c, v);
        Q === null || Q.length === 0 || (f.lyrics = Q);
      }
    }
    return new mA(A, s);
  }
  // returns an array of lyrics (an array because each syllable can have multiple lyrics)
  static createSyllableLyrics(t, A, e) {
    for (var s = [], n = A.split("|"), a = 0; a < n.length; a++) {
      var r = n[a], c = r.indexOf("{"), g = 0;
      if (c >= 0) {
        var h = r.indexOf("}");
        h >= 0 && h > c ? (g = h - c - 1, r = r.substring(0, c) + r.substring(c + 1, h) + r.substring(h + 1, r.length)) : c = -1;
      }
      var f = this.makeLyric(t, r, e);
      c >= 0 && (f.centerStartIndex = c, f.centerLength = g), s.push(f);
    }
    return s;
  }
  static makeLyric(t, A, e) {
    A.length > 1 && A[A.length - 1] === "-" && (e === S.EndingSyllable ? e = S.MiddleSyllable : e === S.SingleSyllable && (e = S.BeginningSyllable), A = A.substring(0, A.length - 1));
    var s = !1;
    A.length > 1 && A[A.length - 1] === "_" && (s = !0, A = A.substring(0, A.length - 1)), (A === "*" || A === "†") && (e = S.Directive);
    var n = new Jt(t, A, e);
    return n.elidesToNext = s, n;
  }
  // takes a string of gabc notations and creates exsurge objects out of them.
  // returns an array of notations.
  static parseNotations(t, A) {
    if (!A)
      return [new St()];
    var e = [], s = [], n = -1, a = (v) => {
      if (s.length > 0) {
        for (var Q = this.createNeumesFromNotes(t, s, n), M = 0; M < Q.length; M++)
          e.push(Q[M]);
        n = -1, s = [];
      }
      v !== null && (v.isClef ? t.activeClef = v : v.isAccidental ? t.activeClef.activeAccidental = v : v.resetsAccidentals && t.activeClef.resetAccidentals(), e.push(v));
    }, r = A.match(HA);
    if (r === null)
      return e;
    for (var c = 0; c < r.length; c++) {
      var g = r[c];
      switch (g) {
        case ",":
          a(new hA());
          break;
        case "`":
          a(new cA());
          break;
        case ";":
          a(new lA());
          break;
        case ":":
          a(new uA());
          break;
        case "::":
          a(new gA());
          break;
        // other gregorio dividers are not supported yet
        case "c1":
          a(t.activeClef = new N(-3, 2));
          break;
        case "c2":
          a(t.activeClef = new N(-1, 2));
          break;
        case "c3":
          a(t.activeClef = new N(1, 2));
          break;
        case "c4":
          a(t.activeClef = new N(3, 2));
          break;
        case "f3":
          a(t.activeClef = new ft(1, 2));
          break;
        case "f4":
          a(t.activeClef = new ft(3, 2));
          break;
        case "cb3":
          a(t.activeClef = new N(1, 2, new vt(0, x.Flat)));
          break;
        case "cb4":
          a(t.activeClef = new N(3, 2, new vt(2, x.Flat)));
          break;
        case "z":
          a(new tt(!0));
          break;
        case "Z":
          a(new tt(!1));
          break;
        case "z0":
          a(new O(!0));
          break;
        // spacing indicators
        case "!":
          n = 0, a(null);
          break;
        case "/":
          n = t.intraNeumeSpacing, a(null);
          break;
        case "//":
          n = t.intraNeumeSpacing * 2, a(null);
          break;
        case " ":
          n = t.intraNeumeSpacing * 2, a(null);
          break;
        default:
          if (g.length > 1 && g[1] === "+") {
            var h = new O();
            h.staffPosition = this.gabcHeightToExsurgeHeight(A[0]), a(h);
          } else if (g.length > 1 && (g[1] === "x" || g[1] === "y" || g[1] === "#")) {
            var f;
            switch (g[1]) {
              case "y":
                f = x.Natural;
                break;
              case "#":
                f = x.Sharp;
                break;
              default:
                f = x.Flat;
                break;
            }
            var d = [];
            this.createNoteFromData(t, t.activeClef, g, d);
            var B = new vt(d[0].staffPosition, f);
            B.trailingSpace = t.intraNeumeSpacing * 2, t.activeClef.activeAccidental = B, a(B);
          } else
            this.createNoteFromData(t, t.activeClef, g, s);
          break;
      }
    }
    return a(null), e;
  }
  static createNeumesFromNotes(t, A, e) {
    for (var s = [], n = 0, a = 0, r = function(p, w, Ct = !0) {
      var et;
      if (w ? et = a : Ct ? et = a - 1 : et = a - 2, !(et < 0)) {
        for (; n <= et; )
          p.addNote(A[n++]);
        return s.push(p), w === !1 && (a--, Ct === !1 && a--, p.keepWithNext = !0, p.trailingSpace = t.intraNeumeSpacing), c;
      }
    }, c = {
      neume: function() {
        return new wt();
      },
      handle: function(p, w) {
        return p.shape === m.Virga ? k : p.shape === m.Stropha ? F : p.shape === m.Oriscus ? f : p.shape === m.Inclinatum ? h : p.shapeModifiers & G.Cavum ? r(new wt(), !0) : g;
      }
    }, g = {
      neume: function() {
        return new wt();
      },
      handle: function(p, w) {
        return p.staffPosition > w.staffPosition ? d : p.staffPosition < w.staffPosition ? p.shape === m.Inclinatum ? v : B : X;
      }
    }, h = {
      neume: function() {
        return new Ut();
      },
      handle: function() {
        return At.shape !== m.Inclinatum ? r(new Ut(), !1) : h;
      }
    }, f = {
      neume: function() {
        return new Et();
      },
      handle: function(p, w) {
        if (p.shape === m.Default) {
          if (p.staffPosition > w.staffPosition)
            return w.shapeModifiers |= G.Ascending, r(new CA(), !0);
          if (p.staffPosition < w.staffPosition)
            return w.shapeModifiers |= G.Descending, r(new mt(), !0);
        } else
          return r(new Et(), !0);
      }
    }, d = {
      neume: function() {
        return new Qt();
      },
      handle: function(p, w) {
        return p.staffPosition > w.staffPosition ? w.shape === m.Oriscus ? E : q : p.staffPosition < w.staffPosition ? p.shape === m.Inclinatum ? M : H : r(new Qt(), !1);
      }
    }, B = {
      neume: function() {
        return new mt();
      },
      handle: function(p, w) {
        return p.shape === m.Default && p.staffPosition > w.staffPosition ? Q : r(new mt(), !1);
      }
    }, v = {
      neume: function() {
        return new Lt();
      },
      handle: function(p, w) {
        return p.shape !== m.Inclinatum ? r(new Lt(), !1) : P;
      }
    }, Q = {
      neume: function() {
        return new Ft();
      },
      handle: function(p, w) {
        return p.shape === m.Default && p.staffPosition < w.staffPosition ? r(new GA(), !0) : r(new Ft(), !1);
      }
    }, M = {
      neume: function() {
        return new Zt();
      },
      handle: function(p, w) {
        return p.shape !== m.Inclinatum ? r(new Zt(), !1) : P;
      }
    }, E = {
      neume: function() {
        return new Vt();
      },
      handle: function(p, w) {
        return p.staffPosition < w.staffPosition ? Y : r(new Vt(), !1);
      }
    }, Y = {
      neume: function() {
        return new kt();
      },
      handle: function(p, w) {
        return r(new kt(), !1);
      }
    }, q = {
      neume: function() {
        return new xt();
      },
      handle: function(p, w) {
        return w.shape === m.Virga && p.shape === m.Inclinatum && p.staffPosition < w.staffPosition ? r(new Qt(), !1, !1) : p.shape === m.Default && p.staffPosition < w.staffPosition ? L : r(new xt(), !1);
      }
    }, L = {
      neume: function() {
        return new Dt();
      },
      handle: function(p, w) {
        return r(new Dt(), !1);
      }
    }, k = {
      neume: function() {
        return new zt();
      },
      handle: function(p, w) {
        return p.shape === m.Inclinatum && p.staffPosition < w.staffPosition ? v : p.shape === m.Virga && p.staffPosition === w.staffPosition ? Z : r(new zt(), !1);
      }
    }, Z = {
      neume: function() {
        return new Ht();
      },
      handle: function(p, w) {
        return p.shape === m.Virga && p.staffPosition === w.staffPosition ? r(new yA(), !0) : r(new Ht(), !1);
      }
    }, F = {
      neume: function() {
        return new T();
      },
      handle: function(p, w) {
        return p.staffPosition === w.staffPosition ? X : r(new T(), !1);
      }
    }, X = {
      neume: function() {
        return new Mt();
      },
      handle: function(p, w) {
        return p.staffPosition === w.staffPosition ? ot : r(new T(), !1, !1);
      }
    }, ot = {
      neume: function() {
        return new SA();
      },
      handle: function(p, w) {
        return r(new Mt(), !1, !1);
      }
    }, H = {
      neume: function() {
        return new Pt();
      },
      handle: function(p, w) {
        return p.shape === m.Default && p.staffPosition > w.staffPosition ? _ : r(new Pt(), !1);
      }
    }, _ = {
      neume: function() {
        return new Nt();
      },
      handle: function(p, w) {
        return p.shape === m.Default && p.staffPosition < w.staffPosition ? r(new IA(), !0) : r(new Nt(), !1);
      }
    }, P = c; a < A.length; ) {
      var Bt = a > 0 ? A[a - 1] : null, At = A[a];
      P = P.handle(At, Bt), a === A.length - 1 && P !== c && r(P.neume(), !0), a++;
    }
    return s.length > 0 && e >= 0 && (s[s.length - 1].trailingSpace = e, e > t.intraNeumeSpacing ? s[s.length - 1].keepWithNext = !1 : s[s.length - 1].keepWithNext = !0), s;
  }
  // appends any notes created to the notes array argument
  static createNoteFromData(t, A, e, s) {
    var n = new bt();
    if (e.length < 1 || (e[0] === "-" && (n.liquescent = b.InitioDebilis, e = e.substring(1)), e.length < 1))
      throw "Invalid note data: " + e;
    var a = this.gabcHeightToExsurgePitch(A, e[0]);
    e[0] === e[0].toUpperCase() && (n.shape = m.Inclinatum), n.staffPosition = this.gabcHeightToExsurgeHeight(e[0]), n.pitch = a;
    for (var r, c = s.length, g = n, h = 1; h < e.length; h++) {
      var f = e[h], d = "\0", B = h + 1 < e.length;
      switch (B && (d = e[h + 1]), f) {
        // rhythmic markings
        case ".":
          r = null, n.morae.length > 0 && (B = !0, Math.abs(n.staffPosition) % 2 === 0 ? d = "1" : d = "0"), r = new pA(t, n), B && d === "1" ? r.positionHint = u.Above : B && d === "0" && (r.positionHint = u.Below), n.morae.push(r);
          break;
        case "_":
          var v = !1;
          for (r = new BA(g); B; ) {
            if (d === "0")
              r.positionHint = u.Below;
            else if (d === "1")
              r.positionHint = u.Above;
            else if (d === "2")
              r.terminating = !0;
            else if (d === "3")
              r.alignment = z.Left;
            else if (d === "4")
              r.alignment = z.Center;
            else if (d === "5")
              r.alignment = z.Right;
            else
              break;
            r.alignment !== z.Default && r.positionHint !== u.Below && (v = !0), h++, B = h + 1 < e.length, B && (d = e[h + 1]);
          }
          g && g.epismata.push(r), g === n && v ? g = n : c >= 0 && s.length > 0 && (g = s[--c]);
          break;
        case "'":
          r = new dA(t, n), B && d === "1" ? r.positionHint = u.Above : B && d === "0" && (r.positionHint = u.Below), n.ictus = r;
          break;
        //note shapes
        case "r":
          B && d === "1" ? (n.acuteAccent = new fA(t, n), h++) : n.shapeModifiers |= G.Cavum;
          break;
        case "s":
          n.shape === m.Stropha && (s.push(n), n = new bt(), c++), n.shape = m.Stropha;
          break;
        case "v":
          n.shape === m.Virga && (s.push(n), n = new bt(), c++), n.shape = m.Virga;
          break;
        case "w":
          n.shape = m.Quilisma;
          break;
        case "o":
          n.shape = m.Oriscus, B && d === "<" ? (n.shapeModifiers |= G.Ascending, h++) : B && d === ">" && (n.shapeModifiers |= G.Descending, h++);
          break;
        case "O":
          n.shape = m.Oriscus, B && d === "<" ? (n.shapeModifiers |= G.Ascending | G.Stemmed, h++) : B && d === ">" ? (n.shapeModifiers |= G.Descending | G.Stemmed, h++) : n.shapeModifiers |= G.Stemmed;
          break;
        // liquescents
        case "~":
          n.shape === m.Inclinatum ? n.liquescent |= b.Small : n.shape === m.Oriscus ? n.liquescent |= b.Large : n.liquescent |= b.Small;
          break;
        case "<":
          n.liquescent |= b.Ascending;
          break;
        case ">":
          n.liquescent |= b.Descending;
          break;
        // accidentals
        case "x":
          n.pitch.step === y.Mi ? n.pitch.step = y.Me : n.pitch.step === y.Ti && (n.pitch.step = y.Te);
          break;
        case "y":
          n.pitch.step === y.Te ? n.pitch.step = y.Ti : n.pitch.step === y.Me ? n.pitch.step = y.Mi : n.pitch.step === y.Du ? n.pitch.step = y.Do : n.pitch.step === y.Fu && (n.pitch.step = y.Fa);
          break;
        case "#":
          n.pitch.step === y.Do ? n.pitch.step = y.Du : n.pitch.step === y.Fa && (n.pitch.step = y.Fu);
          break;
        // gabc special item groups
        case "[":
          for (var Q = ++h; h < e.length && e[h] !== "]"; )
            h++;
          this.processInstructionForNote(t, n, e.substring(Q, h));
          break;
      }
    }
    s.push(n);
  }
  // an instruction in this context is referring to a special gabc coding found after
  // notes between ['s and ]'s. choral signs and braces fall into this
  // category.
  //
  // currently only brace instructions are supported here!
  static processInstructionForNote(t, A, e) {
    var s = e.match(LA);
    if (s !== null) {
      var n = s[1] === "o", a = $.CurlyBrace;
      switch (s[2]) {
        case "b":
          a = $.RoundBrace;
          break;
        case "cb":
          a = $.CurlyBrace;
          break;
        case "cba":
          a = $.AccentedCurlyBrace;
          break;
      }
      var r = s[3] === "0" ? yt.Left : yt.Right;
      s[4] === "{" ? A.braceStart = new It(A, n, a, r) : A.braceEnd = new It(A, n, a, r);
    }
  }
  // takes raw gabc text source and parses it into words. For example, passing
  // in a string of "me(f.) (,) ma(fff)num(d!ewf) tu(fgF'E)am,(f.)" would return
  // an array of four strings: ["me(f.)", "(,)", "ma(fff)num(d!ewf)", "tu(fgF'E)am,(f.)"]
  static splitWords(t) {
    return t = t.trim().replace(/\s/g, " ").replace(/\) (?=[^\)]*(?:\(|$))/g, `)
`), t.split(/\n/g);
  }
  static parseSource(t) {
    if (t.includes("%%")) {
      var A = t.split("%%");
      return this.parseWords(this.splitWords(A));
    }
    return this.parseWords(this.splitWords(t));
  }
  // gabcWords is an array of strings, e.g., the result of splitWords above
  static parseWords(t) {
    for (var A = [], e = 0; e < t.length; e++)
      A.push(this.parseWord(t[e]));
    return A;
  }
  // returns an array of objects, each of which has the following properties
  //  - notations (string)
  //  - lyrics (array of strings)
  static parseWord(t) {
    for (var A = [], e = []; n = Tt.exec(t); )
      e.push(n);
    for (var s = 0; s < e.length; s++) {
      var n = e[s], a = n[1].trim().split("|"), r = n[2];
      A.push({
        notations: r,
        lyrics: a
      });
    }
    return A;
  }
  // returns pitch
  static gabcHeightToExsurgeHeight(t) {
    return t.toLowerCase().charCodeAt(0) - 97 - 6;
  }
  // returns pitch
  static gabcHeightToExsurgePitch(t, A) {
    var e = this.gabcHeightToExsurgeHeight(A), s = t.staffPositionToPitch(e);
    return t.activeAccidental !== null && t.activeAccidental.applyToPitch(s), s;
  }
}
if (typeof document < "u") {
  const o = Object.create(HTMLElement.prototype);
  o.createdCallback = function() {
    const t = new $t();
    t.lyricTextFont = "'Crimson Text', serif", t.lyricTextSize *= 1.2, t.dropCapTextFont = t.lyricTextFont, t.annotationTextFont = t.lyricTextFont;
    let A = !0;
    this.getAttribute("use-drop-cap") === "false" && (A = !1);
    const s = Xt.loadChantScore(t, this.innerText, A), n = this.getAttribute("annotation");
    n && (s.annotation = new qt(t, n));
    const a = this;
    let r = 0;
    const c = () => {
      const g = a.parentElement.clientWidth;
      r !== g && (r = g, s.performLayout(t, () => {
        s.layoutChantLines(t, r, () => {
          a.innerHTML = s.createSvgFragment(t);
        });
      }));
    };
    c(), window.addEventListener ? window.addEventListener("resize", c, !1) : window.attachEvent && window.attachEvent("onresize", c);
  }, o.attachedCallback = function() {
  }, document.registerElement = document.registerElement || function() {
  }, document.registerElement("chant-visual", {
    prototype: o
  });
}
export {
  vt as Accidental,
  x as AccidentalType,
  fA as AcuteAccent,
  qt as Annotation,
  T as Apostropha,
  Ht as Bivirga,
  yt as BraceAttachment,
  It as BracePoint,
  $ as BraceShape,
  ht as Centimeters,
  $t as ChantContext,
  kA as ChantDocument,
  V as ChantLayoutElement,
  tt as ChantLineBreak,
  mA as ChantMapping,
  K as ChantNotationElement,
  QA as ChantScore,
  ct as Clef,
  Lt as Climacus,
  mt as Clivis,
  eA as CurlyBraceVisualizer,
  O as Custos,
  MA as DeviceIndependent,
  Mt as Distropha,
  rt as Divider,
  st as DividerLineVisualizer,
  N as DoClef,
  gA as DoubleBar,
  oA as DropCap,
  ft as FaClef,
  uA as FullBar,
  Xt as Gabc,
  l as GlyphCode,
  D as GlyphVisualizer,
  it as Glyphs,
  lA as HalfBar,
  BA as HorizontalEpisema,
  z as HorizontalEpisemaAlignment,
  dA as Ictus,
  ut as Inches,
  Wt as Language,
  Kt as Latin,
  b as LiquescentType,
  Jt as Lyric,
  S as LyricType,
  Yt as Margins,
  u as MarkingPositionHint,
  lt as Millimeters,
  pA as Mora,
  C as Neume,
  pt as NeumeLineVisualizer,
  bt as Note,
  m as NoteShape,
  G as NoteShapeModifiers,
  Et as Oriscus,
  CA as PesQuassus,
  Zt as PesSubpunctis,
  W as Pitch,
  Qt as Podatus,
  nt as Point,
  Ft as Porrectus,
  GA as PorrectusFlexus,
  Ut as PunctaInclinata,
  wt as Punctum,
  hA as QuarterBar,
  I as QuickSvg,
  R as Rect,
  AA as RoundBraceVisualizer,
  Vt as Salicus,
  kt as SalicusFlexus,
  xt as Scandicus,
  Dt as ScandicusFlexus,
  Rt as Size,
  VA as Spanish,
  y as Step,
  at as TextElement,
  J as TextMeasuringStrategy,
  St as TextOnly,
  EA as ToCentimeters,
  FA as ToInches,
  ZA as ToMillimeters,
  Pt as Torculus,
  Nt as TorculusResupinus,
  IA as TorculusResupinusFlexus,
  SA as Tristropha,
  yA as Trivirga,
  U as Units,
  zt as Virga,
  tA as VirgaLineVisualizer,
  cA as Virgula,
  UA as generateRandomGuid
};
